<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Alish Chhetri - Professional Précis</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Alish Chhetri</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link active" href="./index.html" rel="" target="" aria-current="page">
 <span class="menu-text">Home</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#about-the-author" id="toc-about-the-author" class="nav-link active" data-scroll-target="#about-the-author">About the Author</a></li>
  <li><a href="#week-2" id="toc-week-2" class="nav-link" data-scroll-target="#week-2">Week 2</a>
  <ul class="collapse">
  <li><a href="#se1-programming-over-time" id="toc-se1-programming-over-time" class="nav-link" data-scroll-target="#se1-programming-over-time"><font color="#0058AB"> SE1: Programming Over Time </font></a></li>
  <li><a href="#fb1-introduction-to-software-testing" id="toc-fb1-introduction-to-software-testing" class="nav-link" data-scroll-target="#fb1-introduction-to-software-testing"><font color="#B03A2E"> FB1: Introduction to Software Testing </font></a></li>
  </ul></li>
  <li><a href="#week-3" id="toc-week-3" class="nav-link" data-scroll-target="#week-3">Week 3</a>
  <ul class="collapse">
  <li><a href="#se2-what-is-software-engineering" id="toc-se2-what-is-software-engineering" class="nav-link" data-scroll-target="#se2-what-is-software-engineering"><font color="#0058AB"> SE2: What is Software Engineering? </font></a></li>
  <li><a href="#fb2-code-coverage" id="toc-fb2-code-coverage" class="nav-link" data-scroll-target="#fb2-code-coverage"><font color="#B03A2E"> FB2: Code Coverage </font></a></li>
  </ul></li>
  <li><a href="#week-4" id="toc-week-4" class="nav-link" data-scroll-target="#week-4">Week 4</a>
  <ul class="collapse">
  <li><a href="#se3-how-to-work-well-on-teams" id="toc-se3-how-to-work-well-on-teams" class="nav-link" data-scroll-target="#se3-how-to-work-well-on-teams"><font color="#0058AB"> SE3: How to Work Well on Teams </font></a></li>
  <li><a href="#fb3-fuzzing-breaking-things-with-random-inputs" id="toc-fb3-fuzzing-breaking-things-with-random-inputs" class="nav-link" data-scroll-target="#fb3-fuzzing-breaking-things-with-random-inputs"><font color="#B03A2E"> FB3: Fuzzing: Breaking Things with Random Inputs </font></a></li>
  </ul></li>
  <li><a href="#week-5" id="toc-week-5" class="nav-link" data-scroll-target="#week-5">Week 5</a>
  <ul class="collapse">
  <li><a href="#se4-knowledge-sharing" id="toc-se4-knowledge-sharing" class="nav-link" data-scroll-target="#se4-knowledge-sharing"><font color="#0058AB"> SE4: Knowledge Sharing </font></a></li>
  <li><a href="#fb4-mutation-analysis" id="toc-fb4-mutation-analysis" class="nav-link" data-scroll-target="#fb4-mutation-analysis"><font color="#B03A2E"> FB4: Mutation Analysis </font></a></li>
  </ul></li>
  <li><a href="#week-6" id="toc-week-6" class="nav-link" data-scroll-target="#week-6">Week 6</a>
  <ul class="collapse">
  <li><a href="#executable-examination-and-fall-break" id="toc-executable-examination-and-fall-break" class="nav-link" data-scroll-target="#executable-examination-and-fall-break"><font color="#FFD801"> Executable Examination and Fall Break </font></a></li>
  </ul></li>
  <li><a href="#week-7" id="toc-week-7" class="nav-link" data-scroll-target="#week-7">Week 7</a>
  <ul class="collapse">
  <li><a href="#se5-engineering-for-equity" id="toc-se5-engineering-for-equity" class="nav-link" data-scroll-target="#se5-engineering-for-equity"><font color="#0058AB"> SE5: Engineering for Equity </font></a></li>
  <li><a href="#fb5-mutation-based-fuzzing" id="toc-fb5-mutation-based-fuzzing" class="nav-link" data-scroll-target="#fb5-mutation-based-fuzzing"><font color="#B03A2E"> FB5: Mutation-Based Fuzzing </font></a></li>
  </ul></li>
  <li><a href="#week-8" id="toc-week-8" class="nav-link" data-scroll-target="#week-8">Week 8</a>
  <ul class="collapse">
  <li><a href="#se6-how-to-lead-a-team" id="toc-se6-how-to-lead-a-team" class="nav-link" data-scroll-target="#se6-how-to-lead-a-team"><font color="#0058AB"> SE6: How to Lead a Team </font></a></li>
  <li><a href="#fb6-fuzzing-with-grammars" id="toc-fb6-fuzzing-with-grammars" class="nav-link" data-scroll-target="#fb6-fuzzing-with-grammars"><font color="#B03A2E"> FB6: Fuzzing with Grammars </font></a></li>
  </ul></li>
  <li><a href="#week-9" id="toc-week-9" class="nav-link" data-scroll-target="#week-9">Week 9</a>
  <ul class="collapse">
  <li><a href="#se7-leading-at-scale" id="toc-se7-leading-at-scale" class="nav-link" data-scroll-target="#se7-leading-at-scale"><font color="#0058AB"> SE7: Leading at Scale </font></a></li>
  <li><a href="#fb7-efficient-grammar-fuzzing" id="toc-fb7-efficient-grammar-fuzzing" class="nav-link" data-scroll-target="#fb7-efficient-grammar-fuzzing"><font color="#B03A2E"> FB7: Efficient Grammar Fuzzing </font></a></li>
  </ul></li>
  <li><a href="#week-10" id="toc-week-10" class="nav-link" data-scroll-target="#week-10">Week 10</a>
  <ul class="collapse">
  <li><a href="#se8-style-guides-and-rules" id="toc-se8-style-guides-and-rules" class="nav-link" data-scroll-target="#se8-style-guides-and-rules"><font color="#0058AB"> SE8: Style Guides and Rules </font></a></li>
  <li><a href="#fb8-parsing-inputs" id="toc-fb8-parsing-inputs" class="nav-link" data-scroll-target="#fb8-parsing-inputs"><font color="#B03A2E"> FB8: Parsing Inputs </font></a></li>
  </ul></li>
  <li><a href="#week-11" id="toc-week-11" class="nav-link" data-scroll-target="#week-11">Week 11</a>
  <ul class="collapse">
  <li><a href="#executable-examination" id="toc-executable-examination" class="nav-link" data-scroll-target="#executable-examination"><font color="#FFD801"> Executable Examination </font></a></li>
  </ul></li>
  <li><a href="#week-12" id="toc-week-12" class="nav-link" data-scroll-target="#week-12">Week 12</a>
  <ul class="collapse">
  <li><a href="#se9-code-review" id="toc-se9-code-review" class="nav-link" data-scroll-target="#se9-code-review"><font color="#0058AB"> SE9: Code Review </font></a></li>
  <li><a href="#fb9-reducing-failure-inducing-inputs" id="toc-fb9-reducing-failure-inducing-inputs" class="nav-link" data-scroll-target="#fb9-reducing-failure-inducing-inputs"><font color="#B03A2E"> FB9: Reducing Failure-Inducing Inputs </font></a></li>
  </ul></li>
  <li><a href="#week-13" id="toc-week-13" class="nav-link" data-scroll-target="#week-13">Week 13</a>
  <ul class="collapse">
  <li><a href="#se10-documentation" id="toc-se10-documentation" class="nav-link" data-scroll-target="#se10-documentation"><font color="#0058AB"> SE10: Documentation </font></a></li>
  <li><a href="#db1-introduction-to-debugging" id="toc-db1-introduction-to-debugging" class="nav-link" data-scroll-target="#db1-introduction-to-debugging"><font color="#004d05"> DB1: Introduction to Debugging </font></a></li>
  </ul></li>
  <li><a href="#week-14" id="toc-week-14" class="nav-link" data-scroll-target="#week-14">Week 14</a>
  <ul class="collapse">
  <li><a href="#se11-testing-overview" id="toc-se11-testing-overview" class="nav-link" data-scroll-target="#se11-testing-overview"><font color="#0058AB"> SE11: Testing Overview </font></a></li>
  <li><a href="#db2-tracing-executions" id="toc-db2-tracing-executions" class="nav-link" data-scroll-target="#db2-tracing-executions"><font color="#004d05"> DB2: Tracing Executions </font></a></li>
  </ul></li>
  <li><a href="#week-15" id="toc-week-15" class="nav-link" data-scroll-target="#week-15">Week 15</a>
  <ul class="collapse">
  <li><a href="#se12-unit-testing" id="toc-se12-unit-testing" class="nav-link" data-scroll-target="#se12-unit-testing"><font color="#0058AB"> SE12: Unit Testing </font></a></li>
  <li><a href="#db3-asserting-expectations" id="toc-db3-asserting-expectations" class="nav-link" data-scroll-target="#db3-asserting-expectations"><font color="#004d05"> DB3: Asserting Expectations </font></a></li>
  </ul></li>
  <li><a href="#week-16" id="toc-week-16" class="nav-link" data-scroll-target="#week-16">Week 16</a>
  <ul class="collapse">
  <li><a href="#db4-statistical-debugging" id="toc-db4-statistical-debugging" class="nav-link" data-scroll-target="#db4-statistical-debugging"><font color="#004d05"> DB4: Statistical Debugging </font></a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Professional Précis</h1>
<p class="subtitle lead">Author: Alish Chhetri</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="about-the-author" class="level1">
<h1>About the Author</h1>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Alish_Chhetri.jpeg" class="img-fluid figure-img" width="200"></p>
<figcaption class="figure-caption">Hello, my name is Alish, and I am looking forward to collaborating with everyone throughout the semester.</figcaption>
</figure>
</div>
</section>
<section id="week-2" class="level1">
<h1>Week 2</h1>
<section id="se1-programming-over-time" class="level2">
<h2 class="anchored" data-anchor-id="se1-programming-over-time"><font color="#0058AB"> SE1: Programming Over Time </font></h2>
<section id="summary" class="level4">
<h4 class="anchored" data-anchor-id="summary">Summary</h4>
<p>The preface section of the SE book focuses on distinguishing the terms “software engineering”, “programming” and “computer science”. The section proposes that “software engineering” encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. It also places an emphasis on holding software engineers to the same level of rigor as other engineering disciplines. The programing over time section briefly goes over those points while introducing three fundamental principles that software organizations should keep in mind when designing, architecting, and writing their code. These principles encompass considerations of time and change, how code will need to adapt over the length of its life; scale and growth, how an organization will need to adapt as it evolves; and trade-offs and costs, how an organization makes decisions, based on the lessons of Time and Change and Scale and Growth.</p>
</section>
<section id="reflection" class="level4">
<h4 class="anchored" data-anchor-id="reflection">Reflection</h4>
<p>The preface and programming over time sections outline the foundation for the book’s exploration of software engineering with insights from Google’s unique perspective. I believe this will not only give us an understanding of the material but also a look into how the industry, particularly Google, looks at software engineering and what level of rigor they expect.</p>
</section>
<section id="use-case" class="level4">
<h4 class="anchored" data-anchor-id="use-case">Use-Case</h4>
<p>The knowledge gained from these sections can be applied to any aspect of the Chasten project, as well as to all other programs we write. The emphasis on holding software engineers to the same level of rigor as other engineering disciplines requires us to think beyond the specific use-case of a tool we develop. This ability to apply ourselves rigorously and holistically is crucial in ensuring the success in the field of software engineering.</p>
</section>
</section>
<section id="fb1-introduction-to-software-testing" class="level2">
<h2 class="anchored" data-anchor-id="fb1-introduction-to-software-testing"><font color="#B03A2E"> FB1: Introduction to Software Testing </font></h2>
<section id="summary-1" class="level4">
<h4 class="anchored" data-anchor-id="summary-1">Summary</h4>
<p>The “Introduction to Software Testing” chapter in the Fuzzing book provided valuable insights into the world of software testing. It shows that testing is vital for discovering and rectifying potential issues in the code, contributing to improved software quality and reliability. However, it also highlighted the inherent limitations of testing – it can’t guarantee a completely error-free code. The chapter’s practical example of handling errors, like dividing by zero when using the square root function, illustrated the complexities of software testing, leaving me with a greater understanding of this crucial aspect of software development.</p>
</section>
<section id="reflection-1" class="level4">
<h4 class="anchored" data-anchor-id="reflection-1">Reflection</h4>
<p>The “Introduction to Software Testing” chapter in the Fuzzing book offered valuable insights into testing programs. Testing involves finding bugs in the software, and we can make it more efficient by automating tasks like running tests and checking results. Still, it’s important to realize that testing isn’t foolproof; it can’t ensure that the code is completely free of errors.</p>
</section>
<section id="use-case-1" class="level4">
<h4 class="anchored" data-anchor-id="use-case-1">Use-Case</h4>
<p>The knowledge gained from the “Introduction to Software Testing” chapter can be applied effectively when testing any new software. It shows that testing is vital for discovering and rectifying potential issues in the code, contributing to improved software quality and reliability. In the case of Chasten, we should possibly look into testing different aspects of the program to improve the user experience or the program’s efficiency.</p>
</section>
</section>
</section>
<section id="week-3" class="level1">
<h1>Week 3</h1>
<section id="se2-what-is-software-engineering" class="level2">
<h2 class="anchored" data-anchor-id="se2-what-is-software-engineering"><font color="#0058AB"> SE2: What is Software Engineering? </font></h2>
<section id="summary-2" class="level4">
<h4 class="anchored" data-anchor-id="summary-2">Summary</h4>
<p>Chapter two of <a href="https://abseil.io/resources/swe-book/html/ch01.html">Software Engineering at Google</a> elaborates further on the principles of time, scale, and the trade-offs. The book emphasises the idea of developing a program with a focus on maintaining it over decades, not hours. Software developed using this method requires us to be capable of changing dependencies, technology, or product requirements to ensure the longevity of a program. It then introduces a concept called Hyrum’s Law, a phenomenon in software engineering whereby developers come to depend on all observable traits and behaviors of an interface, even if they are not defined in the contract. The book also states the importance of being able to improve as individual engineers to progress as an organization by sharing knowledge amongst peers.</p>
</section>
<section id="reflection-2" class="level4">
<h4 class="anchored" data-anchor-id="reflection-2">Reflection</h4>
<p>The principles outlined in Chapter two of <a href="https://abseil.io/resources/swe-book/html/ch01.html">“Software Engineering at Google”</a> underscore the critical importance of long-term thinking in software development. The focus on maintaining software over decades rather than hours encourages a mindset that prioritizes adaptability and flexibility. Hyrum’s Law serves as a reminder of the organic nature of software development, highlighting how developers rely on observed behavior, even if it is not a core feature of the program. There is also an emphasis on individual improvement and knowledge sharing and how personal growth contributes to the progress of the entire organization.</p>
</section>
<section id="use-case-2" class="level4">
<h4 class="anchored" data-anchor-id="use-case-2">Use-Case</h4>
<p>The core take away from this chapter is the emphasis on creating a program for the purpose maintaining it over a larger timescale. The chapter also touches on the fact that improvement to the code base is directly correlated with the improvement of the individual. In our case, Chasten will improve as we personally develop as developers. We got this!!</p>
</section>
</section>
<section id="fb2-code-coverage" class="level2">
<h2 class="anchored" data-anchor-id="fb2-code-coverage"><font color="#B03A2E"> FB2: Code Coverage </font></h2>
<section id="summary-3" class="level4">
<h4 class="anchored" data-anchor-id="summary-3">Summary</h4>
<p>The <a href="https://www.fuzzingbook.org/html/Coverage.html#White-Box-Testing">Code Coverage</a> chapter in the Fuzzing book provides a foundational understanding of code coverage in fuzz testing, highlighting its significance in discovering software vulnerabilities and offering practical insights into implementing coverage-guided fuzzing techniques. The section also introduces the concepts of white box and black box testing, essential approaches in software quality assurance. White box testing examines internal code, while black box testing assesses functionality without internal knowledge.</p>
</section>
<section id="reflection-3" class="level4">
<h4 class="anchored" data-anchor-id="reflection-3">Reflection</h4>
<p>In this chapter, I gained a deeper understanding of the pivotal role testing plays in software development. The chapter’s emphasis on testing cases reiterated that it’s not just about writing code but ensuring its correctness and resilience under various scenarios. The book delves into a variety of debugging techniques, showcasing their practical applications, which I found particularly valuable.</p>
</section>
<section id="use-case-3" class="level4">
<h4 class="anchored" data-anchor-id="use-case-3">Use-Case</h4>
<p>For our purposes writing effective test cases is critical for delivering and maintaining the chasten project over a longer timescale. We push ensure that testing is taken as seriously as the create and implementation of new code.</p>
</section>
</section>
</section>
<section id="week-4" class="level1">
<h1>Week 4</h1>
<section id="se3-how-to-work-well-on-teams" class="level2">
<h2 class="anchored" data-anchor-id="se3-how-to-work-well-on-teams"><font color="#0058AB"> SE3: How to Work Well on Teams </font></h2>
<section id="summary-4" class="level4">
<h4 class="anchored" data-anchor-id="summary-4">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch02.html">How to Work Well on Teams</a> chapter in the SE book emphasizes the cultural and social aspects of software engineering at Google, highlighting that software development is a collaborative effort. It stresses the importance of adapting behaviors based on key principles like humility, respect, and trust. In the software world, the myth of the solo developer persists, but the reality is that successful software endeavors, regardless of size, rely on well-functioning teams. To endure over time, software organizations must cultivate a healthy culture centered around the team, rather than individual efforts. This approach encourages creativity, risk-taking, and acceptance of occasional failures within a supportive team environment.</p>
</section>
<section id="reflection-4" class="level4">
<h4 class="anchored" data-anchor-id="reflection-4">Reflection</h4>
<p>This chapter expanded upon the idea that teamwork is essential for successful software development, shedding light on the cultural and social aspects of this collaborative process within Google’s software engineering landscape. It underscored the pivotal role of humility, respect, and trust in fostering effective team dynamics. The chapter also effectively dispelled the myth of the solo software developer and emphasized that, regardless of project size, a well-functioning team is the bedrock of software endeavors.</p>
</section>
<section id="use-case-4" class="level4">
<h4 class="anchored" data-anchor-id="use-case-4">Use-Case</h4>
<p>This chapter has provided invaluable insights into optimizing teamwork and enhancing collaboration within the context of software engineering. It serves as a valuable resource for understanding the intricacies of working effectively as a team, particularly in a dynamic and demanding field like software development. If we want to Chasten to succeed, we must learn how to implement these practices and uphold the principles of humility, respect, and trust. We got this!</p>
</section>
</section>
<section id="fb3-fuzzing-breaking-things-with-random-inputs" class="level2">
<h2 class="anchored" data-anchor-id="fb3-fuzzing-breaking-things-with-random-inputs"><font color="#B03A2E"> FB3: Fuzzing: Breaking Things with Random Inputs </font></h2>
<section id="summary-5" class="level4">
<h4 class="anchored" data-anchor-id="summary-5">Summary</h4>
<p>The <a href="https://www.fuzzingbook.org/html/Fuzzer.html">Fuzzing: Breaking Things with Random Inputs</a> chapter of the Fuzzing Book introduces the idea of fuzzing as a powerful testing technique. Fuzzing involves the systematic generation of random or semi-random inputs to discover vulnerabilities or weaknesses in software applications. This chapter provides a comprehensive overview of fuzzing techniques, including grammar-based fuzzing and mutation-based fuzzing, and delves into the key concepts such as code coverage and crash analysis. It emphasizes the importance of automated fuzzing tools to efficiently discover and exploit software bugs.</p>
</section>
<section id="reflection-5" class="level4">
<h4 class="anchored" data-anchor-id="reflection-5">Reflection</h4>
<p>The chapter’s exploration of various fuzzing techniques, such as grammar-based and mutation-based fuzzing, provides a well-rounded understanding of this testing approach. Additionally, the emphasis on key concepts like code coverage and crash analysis highlights the critical role they play in identifying software bugs. The chapter’s overarching message reinforces the value of automated fuzzing tools in efficiently exposing and addressing these issues, making it a fundamental resource for anyone seeking to enhance software robustness and security.</p>
</section>
<section id="use-case-5" class="level4">
<h4 class="anchored" data-anchor-id="use-case-5">Use-Case</h4>
<p>This chapter has equipped us with invaluable insights into the world of fuzzing, offering a comprehensive understanding of its significance as a testing technique. Just as teamwork is essential in software engineering, fuzzing stands as a powerful and cost-effective tool for improving code coverage and identifying vulnerabilities in our software applications. For our purpose, this testing technique could be employed into the Chasten program to effective test for bugs produced by source code inputs or config files. This technique maybe prove invaluable for Chasten, however I believe that it will be better used during the ladder half of the semester when we start the development of the Astronaught tool.</p>
</section>
</section>
</section>
<section id="week-5" class="level1">
<h1>Week 5</h1>
<section id="se4-knowledge-sharing" class="level2">
<h2 class="anchored" data-anchor-id="se4-knowledge-sharing"><font color="#0058AB"> SE4: Knowledge Sharing </font></h2>
<section id="summary-6" class="level4">
<h4 class="anchored" data-anchor-id="summary-6">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch03.html">Knowledge Sharing</a> chapter in the SE book highlights the idea of organizations understanding their own problem domain and being equipped to answer their own questions. This involves having both experts with knowledge and effective mechanisms to disseminate that knowledge. These mechanisms range from simple actions like asking questions and documenting knowledge to more structured approaches like tutorials and classes. Crucially, fostering a culture of learning within the organization is essential, and this necessitates creating an environment where individuals feel psychologically safe to admit when they lack knowledge.</p>
<p>In addition, the chapter underscores the challenge of “Information islands,” which represent knowledge fragmentation occurring in different parts of an organization that do not communicate with one another or utilize shared resources. In such an environment, each group develops its own unique way of approaching tasks and challenges. This phenomenon often leads to several critical issues:</p>
<ul>
<li><p>Information Fragmentation: Within these isolated “islands,” there exists an incomplete understanding of the larger organizational context and objectives, resulting in suboptimal decision-making.</p></li>
<li><p>Information Duplication: The lack of communication between these groups leads to the duplication of efforts, as each island independently reinvents solutions and processes.</p></li>
<li><p>Information Skew: These islands may adopt varying approaches to address the same issues, potentially causing conflicts and inconsistencies when their methodologies intersect.</p></li>
</ul>
</section>
<section id="reflection-6" class="level4">
<h4 class="anchored" data-anchor-id="reflection-6">Reflection</h4>
<p>Overall, this chapter underscores the significance of knowledge as a critical asset for software engineering organizations. Fostering a culture of open and honest knowledge sharing, underpinned by psychological safety, is essential for organizational resilience and growth. By starting with simple practices like asking questions and documenting knowledge, and by encouraging teaching and accessibility to resources, organizations can efficiently distribute knowledge and adapt to changing circumstances over time.</p>
</section>
<section id="use-case-6" class="level4">
<h4 class="anchored" data-anchor-id="use-case-6">Use-Case</h4>
<p>This chapter has equipped us with invaluable insights into the world of knowledge sharing. In order to implement these practices and foster psychological safety, we must start by ensuring accessibility to resources and expertise, and incentivize teaching and collaboration. We must also recognize that the approach may evolve as the organization’s needs change. After we learn how to effectivily share our knowledge, we will grow as both developers and programmers.</p>
</section>
</section>
<section id="fb4-mutation-analysis" class="level2">
<h2 class="anchored" data-anchor-id="fb4-mutation-analysis"><font color="#B03A2E"> FB4: Mutation Analysis </font></h2>
<section id="summary-7" class="level4">
<h4 class="anchored" data-anchor-id="summary-7">Summary</h4>
<p>The <a href="https://www.fuzzingbook.org/html/MutationAnalysis.html">Mutation Analysis</a> chapter of the Fuzzing Book presents an alternative approach to evaluate the efficiency of a test suite: by introducing mutations, which are simulated defects, into the code and then examining whether the test suite can identify these simulated defects. The underlying concept is that if the test suite cannot detect these artificial mutations, it is likely to overlook actual software bugs as well.</p>
<p>In addition, the chapter emphasizes a limitation of structural coverage measures, which solely measure code execution without verifying the correctness of program outputs. For instance, the presence or absence of assertions in test cases may not affect coverage metrics, even if the test cases fail to validate correct program behavior. Two example test functions, ineffective_test_1 and ineffective_test_2, illustrate this issue:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ineffective_test_1():</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    execute_the_program_as_a_whole()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="va">True</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ineffective_test_2():</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        execute_the_program_as_a_whole()</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span>:</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">pass</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> <span class="va">True</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>These tests may achieve 100% code coverage but are ineffective at discovering actual bugs.</p>
<p>To address this problem, the chapter hints at the idea of injecting bugs into the program to evaluate test suite effectiveness. However, it acknowledges the challenges in doing so, including the potential bias introduced by developers and the time-consuming nature of manually creating these bugs. Consequently, the chapter highlights the need for more robust approaches to ensure the utility of test suites.</p>
</section>
<section id="reflection-7" class="level4">
<h4 class="anchored" data-anchor-id="reflection-7">Reflection</h4>
<p>The concept of mutation analysis introduced in the Fuzzing Book’s chapter offers a valuable perspective on assessing the effectiveness of test suites. It underscores the inadequacy of relying solely on structural coverage measures, as these may not guarantee the correctness of program outputs. The provided code examples, ineffective_test_1 and ineffective_test_2, vividly illustrate the disparity between achieving high coverage and actually uncovering bugs within the software.</p>
<p>Furthermore, the chapter’s discussion on the challenges of injecting artificial bugs raises important considerations about the practicality and potential bias associated with such an approach. This information highlights the need for a balanced and comprehensive testing strategy that not only targets code coverage but also prioritizes the detection of real-world software defects.</p>
</section>
<section id="use-case-7" class="level4">
<h4 class="anchored" data-anchor-id="use-case-7">Use-Case</h4>
<p>This chapter’s insights into test suite evaluation emphasize the need to complement structural coverage measures with mutation analysis, offering a more robust approach to software testing. By introducing simulated defects and assessing whether the test suite can detect them, we can identify vulnerabilities that structural coverage alone might overlook. It’s crucial to recognize that structural coverage metrics should not be the sole focus; instead, we should prioritize comprehensive testing that validates software correctness and robustness. This may require adjustments to our testing methodologies and practices. By incorporating mutation analysis and a holistic testing approach, we can strengthen our projects, enhance software quality, and grow as proficient developers, ultimately delivering more reliable and user-friendly software products.</p>
</section>
</section>
</section>
<section id="week-6" class="level1">
<h1>Week 6</h1>
<section id="executable-examination-and-fall-break" class="level3">
<h3 class="anchored" data-anchor-id="executable-examination-and-fall-break"><font color="#FFD801"> Executable Examination and Fall Break </font></h3>
</section>
</section>
<section id="week-7" class="level1">
<h1>Week 7</h1>
<section id="se5-engineering-for-equity" class="level2">
<h2 class="anchored" data-anchor-id="se5-engineering-for-equity"><font color="#0058AB"> SE5: Engineering for Equity </font></h2>
<section id="summary-8" class="level4">
<h4 class="anchored" data-anchor-id="summary-8">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch04.html">Engineering for Equity</a> chapter of the Software Engineering book highlights the importance of recognizing and addressing bias in software development. It emphasizes the need for diversity and inclusivity in the industry to ensure that software products are designed for a wide range of users. The chapter discusses how unconscious bias can inadvertently harm underrepresented groups and lead to failures in product development. A case study about Google’s image recognition algorithms failing to consider racial inclusion is presented as an example of such failures. The chapter stresses the need for engineers to focus on understanding diverse user demographics and challenges, as well as the importance of building multicultural capacity in development teams. It also advocates for inclusive design from the beginning of the development process and emphasizes the responsibility of engineers in making equitable systems. The chapter encourages continuous improvement, measurement of equity, and collaboration with diversity and inclusion experts to create more inclusive software products.</p>
</section>
<section id="reflection-8" class="level4">
<h4 class="anchored" data-anchor-id="reflection-8">Reflection</h4>
<p>The chapter serves as a reminder of the ethical and practical imperative of addressing bias and promoting inclusivity in software engineering. It acknowledges that the industry has a long way to go in achieving true inclusivity and diversity. It calls for a shift in mindset, from building for everyone to building with everyone, involving users at every stage of product development. It stresses the need for engineers to understand the impact of their products on a diverse user base and challenges traditional approaches that prioritize speed over equity.</p>
</section>
<section id="use-case-8" class="level4">
<h4 class="anchored" data-anchor-id="use-case-8">Use-Case</h4>
<p>This chapter provides a valuable guide for software engineers and organizations to make inclusivity and diversity central to their product development processes. It encourages engineers to consider all user groups, especially those who may face challenges in using their products, and to collaborate with experts in diversity and inclusion. By following these principles, engineers and organizations can build more equitable and inclusive software that serves a broader range of users, ultimately improving the industry as a whole.</p>
</section>
</section>
<section id="fb5-mutation-based-fuzzing" class="level2">
<h2 class="anchored" data-anchor-id="fb5-mutation-based-fuzzing"><font color="#B03A2E"> FB5: Mutation-Based Fuzzing </font></h2>
<section id="summary-9" class="level4">
<h4 class="anchored" data-anchor-id="summary-9">Summary</h4>
<p>The <a href="https://www.fuzzingbook.org/html/MutationFuzzer.html">Mutation-Based Fuzzing</a> chapter of the Fuzzing Book introduces the idea of mutational-based fuzzing, a technique used in software engineering testing. It involves making small, random modifications to valid inputs to explore a wider range of program behaviors while maintaining their structural integrity. Mutational fuzzing is particularly valuable in testing software that interacts with external data sources, such as file parsers, network protocols, or APIs. This approach helps identify edge cases, uncover hidden software bugs, and ensure the robustness and reliability of programs that process various inputs.</p>
<p>The chapter provides an example of mutation based fuzzing in the following code blocks:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mutate(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">str</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return s with a random mutation applied"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    mutators <span class="op">=</span> [</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        delete_random_character,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        insert_random_character,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        flip_random_character</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    mutator <span class="op">=</span> random.choice(mutators)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># print(mutator)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mutator(s)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="bu">repr</span>(mutate(<span class="st">"A quick brown fox"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<pre><code>example output:

'A qzuick brown fox'
' quick brown fox'
'A quick Brown fox'
'A qMuick brown fox'
'A qu_ick brown fox'
'A quick bXrown fox'
'A quick brown fx'
'A quick!brown fox'
'A! quick brown fox'
'A quick brownfox'</code></pre>
<p>The mutate function take a string as an input and applies a random mutation to it by choosing from a set of mutator functions: delete_random_character, insert_random_character, and flip_random_character. It uses the random.choice function to randomly select one of these mutators and then applies it to the input string. The provided loop prints ten randomly mutated versions of the input string, “A quick brown fox.” The example output shows us how the input text can be modified, however you can still clearly tell what the original input was, thus demonstrating the mutation of existing content and not generation of new content.</p>
</section>
<section id="reflection-9" class="level4">
<h4 class="anchored" data-anchor-id="reflection-9">Reflection</h4>
<p>The Mutation-Based Fuzzing chapter of the Fuzzing Book introduces mutational-based fuzzing as a practical technique for software engineering testing. It emphasizes the significance of maintaining structural validity in input modifications, allowing for more precise exploration of a program’s behaviors. The provided code example illustrates the process of mutating existing content, highlighting the approach’s ability to generate subtle variations while retaining the original context. This chapter showcases the value of mutational fuzzing in enhancing software robustness, particularly in scenarios involving external data sources, and serves as a reminder of the importance of nuanced testing methods that go beyond basic input validation.</p>
</section>
<section id="use-case-9" class="level4">
<h4 class="anchored" data-anchor-id="use-case-9">Use-Case</h4>
<p>Developers can apply the principles outlined in this chapter to systematically mutate valid inputs, allowing for the exploration of program behaviors beyond mere input processing. This approach is particularly valuable when testing software that interacts with external data sources such as file parsers which fits our needs. By implementing mutational fuzzing, we can identify edge cases, uncover hidden software defects, and ensure comprehensive software quality and reliability, ultimately enhancing the overall testing and quality assurance processes in software development.</p>
</section>
</section>
</section>
<section id="week-8" class="level1">
<h1>Week 8</h1>
<section id="se6-how-to-lead-a-team" class="level2">
<h2 class="anchored" data-anchor-id="se6-how-to-lead-a-team"><font color="#0058AB"> SE6: How to Lead a Team </font></h2>
<section id="summary-10" class="level4">
<h4 class="anchored" data-anchor-id="summary-10">Summary</h4>
<p>The chapter <a href="https://abseil.io/resources/swe-book/html/ch05.html">How to Lead a Team</a> in “Software Engineering at Google” delves into the distinctive nature of team leadership compared to individual technical roles. It emphasizes that while exceptional software engineers might not automatically excel as managers, successful organizations foster diverse career paths for both individual contributors and managers. Google’s perspective underscores that though technical proficiency is valuable, a manager’s core competencies lie in their social skills. Effective managers primarily enable their teams by emphasizing leadership, directing them towards the right goals, and shielding them from external disruptions. This approach is underscored by the foundational principles of humility, trust, and respect. The chapter’s essence lies in the transformation from traditional “management” to a focus on leadership, influence, and service to the team, emphasizing delegation rather than performing tasks independently. Ultimately, it stresses the importance of guiding the team’s focus, direction, and momentum.</p>
</section>
<section id="reflection-10" class="level4">
<h4 class="anchored" data-anchor-id="reflection-10">Reflection</h4>
<p>The chapter stresses a significant change in leadership methods, moving from traditional authoritative approaches to a more supportive and encouraging style. It emphasizes the importance of prioritizing the team’s well-being and productivity over mere task completion. This transformation involves creating an environment where individuals feel guided and respected rather than strictly managed. Rooted in values such as humility, trust, and respect, this evolved leadership model fosters a culture of learning, trust, and collaboration. It advises leaders to understand that success is not just about completing tasks but about empowering each team member to perform at their best. This new leadership style focuses on guiding, supporting, and enabling the team to achieve its objectives, fostering a positive, growth-oriented atmosphere that enhances productivity and collective success.</p>
</section>
<section id="use-case-10" class="level4">
<h4 class="anchored" data-anchor-id="use-case-10">Use-Case</h4>
<p>Emphasizing respect and humility is crucial for effective collaboration and knowledge exchange. Even without explicit ‘managers,’ embracing these principles positively influences work dynamics. Personal experiences affirm the impact of positive pressure, encouraging the team to maintain trust, delegate tasks effectively, and foster an environment that accommodates mistakes while ensuring fair task distribution based on individual abilities.</p>
</section>
</section>
<section id="fb6-fuzzing-with-grammars" class="level2">
<h2 class="anchored" data-anchor-id="fb6-fuzzing-with-grammars"><font color="#B03A2E"> FB6: Fuzzing with Grammars </font></h2>
<section id="summary-11" class="level4">
<h4 class="anchored" data-anchor-id="summary-11">Summary</h4>
<p>The chapter <a href="https://www.fuzzingbook.org/html/Grammars.html#Fuzzing-with-Grammars">Fuzzing with Grammars</a> delves into the powerful use of grammars to generate syntactically valid inputs. It discusses how grammars can create structured, randomized string combinations, applicable for various functions and processes. By defining a set of rules, grammars help formalize the structuring of inputs, similar to how natural language follows a grammar that enables effective communication among humans. The chapter introduces the concept of Grammars, demonstrating their application in generating controlled yet complex string inputs that can be used for functions.</p>
<p>Additionally, it highlights the versatility of grammars, indicating their application not only in formal languages like computer inputs but also in producing natural language. The chapter showcases an example of using a grammar to generate titles for a book.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>TITLE_GRAMMAR: Grammar <span class="op">=</span> {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;start&gt;"</span>: [<span class="st">"&lt;title&gt;"</span>],</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;title&gt;"</span>: [<span class="st">"&lt;topic&gt;: &lt;subtopic&gt;"</span>],</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;topic&gt;"</span>: [<span class="st">"Generating Software Tests"</span>, <span class="st">"&lt;fuzzing-prefix&gt;Fuzzing"</span>, <span class="st">"The Fuzzing Book"</span>],</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;fuzzing-prefix&gt;"</span>: [<span class="st">""</span>, <span class="st">"The Art of "</span>, <span class="st">"The Joy of "</span>],</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;subtopic&gt;"</span>: [<span class="st">"&lt;subtopic-main&gt;"</span>,</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                   <span class="st">"&lt;subtopic-prefix&gt;&lt;subtopic-main&gt;"</span>,</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                   <span class="st">"&lt;subtopic-main&gt;&lt;subtopic-suffix&gt;"</span>],</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;subtopic-main&gt;"</span>: [<span class="st">"Breaking Software"</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Generating Software Tests"</span>,</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"Principles, Techniques and Tools"</span>],</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;subtopic-prefix&gt;"</span>: [<span class="st">""</span>, <span class="st">"Tools and Techniques for "</span>],</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;subtopic-suffix&gt;"</span>: [<span class="st">" for &lt;reader-property&gt; and &lt;reader-property&gt;"</span>,</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                          <span class="st">" for &lt;software-property&gt; and &lt;software-property&gt;"</span>],</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;reader-property&gt;"</span>: [<span class="st">"Fun"</span>, <span class="st">"Profit"</span>],</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="st">"&lt;software-property&gt;"</span>: [<span class="st">"Robustness"</span>, <span class="st">"Reliability"</span>, <span class="st">"Security"</span>],</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Set</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>titles: Set[<span class="bu">str</span>] <span class="op">=</span> <span class="bu">set</span>()</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="bu">len</span>(titles) <span class="op">&lt;</span> <span class="dv">10</span>:</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    titles.add(simple_grammar_fuzzer(</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        grammar<span class="op">=</span>TITLE_GRAMMAR, max_nonterminals<span class="op">=</span><span class="dv">10</span>))</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>titles</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>{<span class="st">'Fuzzing: Generating Software Tests'</span>,</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a> <span class="st">'Fuzzing: Principles, Techniques and Tools'</span>,</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a> <span class="st">'Generating Software Tests: Breaking Software'</span>,</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a> <span class="st">'Generating Software Tests: Breaking Software for Robustness and Robustness'</span>,</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a> <span class="st">'Generating Software Tests: Principles, Techniques and Tools'</span>,</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a> <span class="st">'Generating Software Tests: Principles, Techniques and Tools for Profit and Fun'</span>,</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a> <span class="st">'Generating Software Tests: Tools and Techniques for Principles, Techniques and Tools'</span>,</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a> <span class="st">'The Fuzzing Book: Breaking Software'</span>,</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a> <span class="st">'The Fuzzing Book: Generating Software Tests for Profit and Profit'</span>,</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a> <span class="st">'The Fuzzing Book: Generating Software Tests for Robustness and Robustness'</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The Python code block provided presents a natural language grammar utilized to generate book titles, as explained. The code creates a grammar structure TITLE_GRAMMAR comprising different components (e.g., “start”, “title”, “topic”) and their respective sets of options. Utilizing this grammar, the code generates 10 unique book titles by applying the simple_grammar_fuzzer() function, populating the titles set with the resulting strings. The while loop ensures the generation of titles until the set contains 10 unique elements. The output showcases the 10 distinct book title options created from this grammar, each exhibiting various combinations as defined in the grammar rules.</p>
</section>
<section id="reflection-and-use-case" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case">Reflection and Use-Case</h4>
<p>The chapter’s exploration of using grammars to generate structured and varied string inputs provides a powerful method applicable to testing, simulation, and data generation. This strategy holds immense potential for Chasten, particularly in software testing, as it allows for the automated creation of diverse test cases without manual input, thereby enhancing test coverage across various software functionalities. The adaptability of grammars, exemplified by producing natural language outputs, presents possibilities for auto-generating user interfaces, content, or communication templates. Incorporating grammars into Chasten’s testing strategies can optimize data generation, streamline testing tasks, and enable more efficient development and testing phases, significantly revolutionizing how the project handles mutation-based fuzzing, especially in constructing XPath expressions.</p>
</section>
</section>
</section>
<section id="week-9" class="level1">
<h1>Week 9</h1>
<section id="se7-leading-at-scale" class="level2">
<h2 class="anchored" data-anchor-id="se7-leading-at-scale"><font color="#0058AB"> SE7: Leading at Scale </font></h2>
<section id="summary-12" class="level4">
<h4 class="anchored" data-anchor-id="summary-12">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch06.html">Leading at Scale</a> chapter discusses the evolution of leadership from an individual contributor to a team leader and beyond. It explores the natural progression of engineers into leadership roles managing related teams, emphasizing that with increased responsibility comes a shift to higher-level, abstract problem-solving. This chapter highlights the “three Always of leadership”: Always Be Deciding, which involves making high-level strategic decisions; Always Be Leaving, encouraging leaders to enable self-sufficiency within their teams to avoid becoming a single point of failure (SPOF); and Always Be Scaling, focusing on protecting personal resources while developing self-sufficient teams. The chapter emphasizes that success as a leader involves building self-driving teams, strong leaders, healthy processes, and a culture of persistence over time.</p>
</section>
<section id="reflection-11" class="level4">
<h4 class="anchored" data-anchor-id="reflection-11">Reflection</h4>
<p>The chapter insightfully portrays the journey of an engineer evolving into a leader and the inherent challenges of transitioning from technical expertise to higher-level decision-making and team management. It adeptly emphasizes the necessity for leaders to delegate, empower self-sufficiency within their teams, and protect their own resources while ensuring team growth. The three principles - Deciding, Leaving, and Scaling - offer a practical framework for effective leadership, illustrating the need to navigate from technical proficiency to organizational orchestration. The concept of not being indispensable but rather fostering a self-sufficient organization resonates profoundly, underlining the importance of building a sustainable team structure. Additionally, the cycle of success elucidates the iterative nature of problem-solving, the emergence of new challenges, and the continuous cycle of learning and growth in leadership roles.</p>
</section>
<section id="use-case-11" class="level4">
<h4 class="anchored" data-anchor-id="use-case-11">Use-Case</h4>
<p>While our team currently operates without explicit leadership roles, this doesn’t deter us from maximizing productivity and efficiency. We believe in a leadership approach that allows each team member to adopt strategies without the constraints of micromanagement, fostering progress. Embracing failure as a learning component remains crucial, even within smaller projects and organizations. Despite the absence of defined leaders beyond the instructor and student technical leads, we contemplate the potential introduction of more formal roles, aiming to enhance alignment and direction. Nevertheless, it’s pivotal that each team member is afforded the opportunity to lead at different junctures, recognizing that our team isn’t solely a software engineering group, but a class where the development of leadership skills is an integral part of our collective growth.</p>
</section>
</section>
<section id="fb7-efficient-grammar-fuzzing" class="level2">
<h2 class="anchored" data-anchor-id="fb7-efficient-grammar-fuzzing"><font color="#B03A2E"> FB7: Efficient Grammar Fuzzing </font></h2>
<section id="summary-13" class="level4">
<h4 class="anchored" data-anchor-id="summary-13">Summary</h4>
<p>In this <a href="https://www.fuzzingbook.org/html/GrammarFuzzer.html">chapter</a>, the transformation from a string-based to a tree-based algorithm marks a significant advancement, offering enhanced speed and control in generating fuzz inputs. Derivation trees, adopted in grammar-based fuzzing, provide a structured representation enabling more efficient and controlled string generation by navigating expansions systematically.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GrammarFuzzer(GrammarFuzzer):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expand_node_min_cost(<span class="va">self</span>, node: DerivationTree) <span class="op">-&gt;</span> DerivationTree:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.log:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">"Expanding"</span>, all_terminals(node), <span class="st">"at minimum cost"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.expand_node_by_cost(node, <span class="bu">min</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> GrammarFuzzer(GrammarFuzzer):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expand_node(<span class="va">self</span>, node: DerivationTree) <span class="op">-&gt;</span> DerivationTree:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.expand_node_min_cost(node)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> GrammarFuzzer(EXPR_GRAMMAR, log<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>display_tree(derivation_tree)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="gfnode.PNG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Example of DerivationTree</figcaption>
</figure>
</div>
<p>Within the code snippets, the extension of the GrammarFuzzer class introduces methods like expand_node_min_cost, streamlining the expansion process by aiming for minimum cost, while the expand_node method acts as a straightforward interface, enhancing the derivation tree expansion within fuzz input generation. This approach exemplifies the pivotal shift from traditional string-based algorithms to tree-based methodologies, fundamentally improving control and efficiency in the fuzzing process.</p>
</section>
<section id="reflection-and-use-case-1" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-1">Reflection and Use-Case</h4>
<p>The chapter delves into refining a string-based algorithm into a tree-based approach, significantly advancing grammar-based fuzzing. This shift from traditional string-based to tree-based derivation introduces derivation trees, allowing for more controlled and efficient string generation. The structured expansion of symbols in the derivation tree mitigates issues like infinite expansions in traditional methods. Integrating this approach into chasten, particularly within XPath expressions, can automate the generation of diverse yet structured test inputs. This implementation could revolutionize how mutation-based fuzzing is applied, improving test coverage and enabling robust test scenarios, enhancing the software’s testing capabilities.</p>
</section>
</section>
</section>
<section id="week-10" class="level1">
<h1>Week 10</h1>
<section id="se8-style-guides-and-rules" class="level2">
<h2 class="anchored" data-anchor-id="se8-style-guides-and-rules"><font color="#0058AB"> SE8: Style Guides and Rules </font></h2>
<section id="summary-14" class="level4">
<h4 class="anchored" data-anchor-id="summary-14">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch08.html">Style Guides and Rules</a> chapter of the SE at Google book explores the crucial role of rules and guidance within engineering organizations, with Google as a prime example. It emphasizes the tailored approach in Google’s style guides for various programming languages, shaped by language traits and evolving industry standards. One case study illustrates the adaptive nature of rules, such as allowing std::unique_ptr in C++11 after its alignment with style guidance became evident. Additionally, the narrative underlines the necessity of periodically changing rules, demonstrated by Google’s shift in Python naming conventions. This transition from CamelCase to snake_case highlights the need for adaptability to maintain effective guidelines. Overall, the chapter provides insight into the dynamic nature of rules and guidance, essential for sustaining an efficient codebase within a dynamic engineering landscape.</p>
</section>
<section id="reflection-12" class="level4">
<h4 class="anchored" data-anchor-id="reflection-12">Reflection</h4>
<p>The chapter offers a deep insight into the significance of rules and guidelines in a large-scale engineering environment. It showcases how stringent rules and adaptable guidance serve as the backbone of coding practices, aligning with organizational values and goals. The dynamic nature of different programming languages necessitates tailored guidelines, illustrating the importance of rules in maintaining a manageable codebase. The focus on developing rules that serve specific goals rather than creating exhaustive rulebooks provides clarity and prevents unnecessary overhead. Moreover, it underscores the trade-off between consistency and flexibility, showcasing the delicate balance in ensuring code quality while not overburdening engineers with an excessive number of rules. Ultimately, the chapter emphasizes the critical role of rules in shaping a sustainable engineering environment that’s resilient to scale and time, enabling effective codebase management while supporting a common development pattern.</p>
</section>
<section id="use-case-12" class="level4">
<h4 class="anchored" data-anchor-id="use-case-12">Use-Case</h4>
<p>Implementing guidelines to ensure adaptability and scalability is essential to growth of chasten. By continuously evaluating data, we can adjust rules to suit changing needs. It’s crucial to avoid making every practice a rigid rule, maintaining flexibility. Consistency in adhering to these guidelines is paramount for a cohesive approach. Automating enforcement wherever feasible streamlines the process and ensures adherence to the established practices. Integrating these principles into our operations allows for a balanced and adaptable approach, ensuring sustained efficiency and growth within our system.</p>
</section>
</section>
<section id="fb8-parsing-inputs" class="level2">
<h2 class="anchored" data-anchor-id="fb8-parsing-inputs"><font color="#B03A2E"> FB8: Parsing Inputs </font></h2>
<section id="summary-15" class="level4">
<h4 class="anchored" data-anchor-id="summary-15">Summary</h4>
<p>The <a href="https://www.fuzzingbook.org/html/Parser.html">Parsing Inputs</a> chapter within the FB book delves into the practical application of grammars, not just for generating strings but also for parsing, deconstructing strings into derivation trees, and subsequently recombining these components for fuzzing—generating new, valid inputs. This chapter introduces Parsing Expression Grammar (PEG) parsers and Earley parsers, emphasizing the differences in their parsing methodologies. PEGs prioritize ordered choice, whereas Earley parsers exhibit adaptability across various grammar structures. It underscores the significance of grammars in parsing, emphasizing the creation of derivation trees, nuances in constructing PEGs, and the flexibility of Earley parsers in handling diverse context-free grammars. Overall, this chapter highlights the fundamental role of grammars in both parsing and generating strings through distinct parsing techniques, fostering a deeper understanding of their practical applications.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PEGParser(Parser):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> parse_prefix(<span class="va">self</span>, text):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        cursor, tree <span class="op">=</span> <span class="va">self</span>.unify_key(<span class="va">self</span>.start_symbol(), text, <span class="dv">0</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cursor, [tree]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>mystring <span class="op">=</span> <span class="st">"1 * (2 + 3.35)"</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> tree <span class="kw">in</span> peg.parse(mystring):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> tree_to_string(tree) <span class="op">==</span> mystring</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    display(display_tree(tree))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="parse.PNG" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Output</figcaption>
</figure>
</div>
<p>The code snippet uses the PEGParser to parse a given string, verifying the precision of the resulting tree structure through an assertion test. Additionally, it presents a visual representation, which is displayed alongside the code snippet.</p>
</section>
<section id="reflection-and-use-case-2" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-2">Reflection and Use-Case</h4>
<p>The Parsing Inputs chapter introduces PEG and Earley parsers, highlighting their distinct parsing methods. Integrating these techniques into Chasten could greatly improve its pattern recognition within Python AST. By employing these methods, Chasten could create more accurate linting rules, offering precise pattern identification without relying on complex AST frameworks or limited regular expressions, thereby enhancing its code evaluation.</p>
</section>
</section>
</section>
<section id="week-11" class="level1">
<h1>Week 11</h1>
<section id="executable-examination" class="level3">
<h3 class="anchored" data-anchor-id="executable-examination"><font color="#FFD801"> Executable Examination </font></h3>
</section>
</section>
<section id="week-12" class="level1">
<h1>Week 12</h1>
<section id="se9-code-review" class="level2">
<h2 class="anchored" data-anchor-id="se9-code-review"><font color="#0058AB"> SE9: Code Review </font></h2>
<section id="summary-16" class="level4">
<h4 class="anchored" data-anchor-id="summary-16">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch09.html">Code Review</a> chapter in the <a href="https://abseil.io/resources/swe-book">Software Engineering at Google book</a> delves into Google’s approach to code evaluation and its overarching significance. Code review stands as a crucial phase in ensuring uniformity and excellence within a software engineering venture, warranting earnest consideration. At Google, this process is divided into three fundamental aspects: ensuring correctness and comprehension of the code, verifying its appropriateness for the project, and evaluating its readability and adherence to defined style rules. Split into steps, the process starts with the author summarizing and explaining the changes, followed by another person’s review and feedback. Iterations continue until the code aligns with the standards and requirements. Professionalism and clear communication are pivotal to minimize misinterpretation and enhance efficiency, despite the inherent slowdown in the change implementation process. Despite this, Google finds that the benefits of rigorous code review significantly outweigh the drawbacks, ensuring consistency, quality, and a shared understanding among team members. Upon multiple approvals using LGTM (“Looks good to me”), the changes are then implemented.</p>
</section>
<section id="reflection-and-use-case-3" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-3">Reflection and Use-Case</h4>
<p>The chapter underscores efficient code review methods, shedding light on challenges encountered in our Chasten project, notably the involvement of 3 to 5 reviewers per change, often resulting in superficial assessments. Addressing this issue involves recognizing that a shift towards a single reviewer system emerges as a potential solution, promising improved accountability and depth in assessments. The need for detailed change descriptions resonates with our team’s lack of clear commit messages and timing. Increasing commit frequency would offer a clearer development trail for reviewers. Implementing these changes could significantly enhance our code review process.</p>
</section>
</section>
<section id="fb9-reducing-failure-inducing-inputs" class="level2">
<h2 class="anchored" data-anchor-id="fb9-reducing-failure-inducing-inputs"><font color="#B03A2E"> FB9: Reducing Failure-Inducing Inputs </font></h2>
<section id="summary-17" class="level4">
<h4 class="anchored" data-anchor-id="summary-17">Summary</h4>
<p>The <a href="https://www.fuzzingbook.org/html/Reducer.html">Reducing Failure-Inducing Inputs</a> chapter in the <a href="https://www.fuzzingbook.org/">fuzzing book</a> delves into Delta Debugging as a valuable technique for pinpointing code faults. It presents two key approaches: one employing a binary search algorithm to iteratively dissect string inputs, isolating the minimal failing part, while the other utilizes grammar-based reduction, intelligently splitting inputs using defined tokens. This method proves effective across various input types, allowing for precise identification of code failure origins. The chapter emphasizes the importance of minimizing failure-inducing inputs for effective testing and debugging, highlighting delta debugging as a straightforward and reliable algorithm for simplifying test cases. Additionally, it advocates for the use of grammar-based reduction when dealing with intricate syntactic inputs due to its quicker processing speed and superior outcomes in achieving minimized inputs for testing purposes.</p>
</section>
<section id="reflection-and-use-case-4" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-4">Reflection and Use-Case</h4>
<p>Reflection on the insights from the “Reducing Failure-Inducing Inputs” chapter prompts the Chasten and Cellveyor teams to recognize the relevance of Delta Debugging principles in addressing software issues efficiently. Although the project’s scale may not entirely align with exhaustive debugging, understanding this methodology remains crucial. Embracing delta debugging concepts equips teams to rapidly pinpoint and address errors, notably streamlining the identification of fuzzing inputs—a significant time-saving aspect in testing. However, its effectiveness hinges on input data nature, necessitating a balanced approach between simplicity and efficiency in debugging strategies. Acknowledging these intricacies, the chapter encourages exploring alternative reduction techniques like Grammar-Based Input Reduction.</p>
<p>In the context of Chasten’s Python code analysis using XPATH, leveraging Delta Debugging holds promise to automate error identification and isolation, augmenting the software’s fault detection capabilities. Additionally, considering the limitations of Delta Debugging, exploring Grammar-Based Input Reduction for syntactic constraints in Python code could offer an alternative, more efficient reduction strategy. These strategies, derived from the chapter’s insights, provide actionable steps to enhance error identification and streamline debugging processes within the Chasten project.</p>
</section>
</section>
</section>
<section id="week-13" class="level1">
<h1>Week 13</h1>
<section id="se10-documentation" class="level2">
<h2 class="anchored" data-anchor-id="se10-documentation"><font color="#0058AB"> SE10: Documentation </font></h2>
<section id="summary-18" class="level4">
<h4 class="anchored" data-anchor-id="summary-18">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch10.html">Documentation</a> chapter in the <a href="https://abseil.io/resources/swe-book">Software Engineering at Google</a> book acknowledged that while there have been advancements in documentation quality, it still doesn’t hold the same precedence as testing within the engineering culture. Unlike tests that can be structured, automated, and follow prescribed patterns, documents lack such uniformity due to their subjective nature and asynchronous evaluation by readers. However, there’s a growing acknowledgment of documentation’s significance, with evolving processes for document development. Despite being superior to many engineering environments, Google recognizes the need for a collective understanding that engineers themselves are both the problem and the solution regarding documentation quality. Embracing documentation as an essential part of their responsibilities can significantly save time and effort in the long run, especially for code expected to endure. The key takeaways emphasize the vital importance of documentation, its integration into the developer workflow, the need for focused documents, and the importance of writing for the intended audience rather than the author.</p>
</section>
<section id="reflection-and-use-case-5" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-5">Reflection and Use-Case</h4>
<p>This chapter changed how I see documentation, urging us to treat it like code in our development work. It talks about setting rules, controlling documentation, assigning responsibilities, and checking how effective it is. There are different types of documents, like reference guides and design docs, which help us work together better. It shows how important good documentation is, saying it’s just as vital as writing code. For our Chasten project, this means using code-like practices for documentation, assigning ownership, improving how we track and review it, focusing on making it easy for our audience, and using different types of docs to improve our work.</p>
</section>
</section>
<section id="db1-introduction-to-debugging" class="level2">
<h2 class="anchored" data-anchor-id="db1-introduction-to-debugging"><font color="#004d05"> DB1: Introduction to Debugging </font></h2>
<section id="summary-19" class="level4">
<h4 class="anchored" data-anchor-id="summary-19">Summary</h4>
<p>The <a href="https://www.debuggingbook.org/html/Intro_Debugging.html">Introduction to Debugging</a> chapter of the <a href="https://www.debuggingbook.org/">Debugging Book</a> presents foundational principles for effective debugging practices. It emphasizes moving away from reactive approaches—like scattered print statements and arbitrary code alterations—to more systematic and focused methods. Understanding the essence of defects, faults, and failures in programming, the chapter introduces the importance of tracing back fault propagation systematically to identify underlying defects. Through the application of the scientific method, developers are encouraged to formulate and test hypotheses rigorously, leveraging repeated experiments and observations. Zeller advocates for a methodical approach: comprehensively diagnosing issues before fixing defects, maintaining detailed logs of observations and hypotheses, and even employing “rubber ducking”—explaining problems aloud—to unravel intricate coding issues. Ultimately, the chapter stresses the significance of a systematic debugging process grounded in clear observations, methodical analysis, and deliberate experimentation for effective defect resolution.</p>
</section>
<section id="reflection-and-use-case-6" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-6">Reflection and Use-Case</h4>
<p>The debugging chapter serves as a comprehensive guide, emphasizing the significance of a structured approach to address coding issues. While some content felt familiar, the focus on hypothesis creation and meticulous documentation stands out as pivotal. Integrating these concepts into our debugging process by encouraging hypothesis-driven analysis and meticulous documentation will significantly enhance our team’s debugging efficiency. Applying the cause-and-effect chain principle in writing test cases and embracing the systematic approach of the scientific method in diagnosing errors will amplify our ability to debug programs effectively. This chapter underscores the importance of methodical debugging, advocating for a hypothesis-based, systematic approach, providing a robust framework for debugging practices and fostering a more reliable codebase.</p>
</section>
</section>
</section>
<section id="week-14" class="level1">
<h1>Week 14</h1>
<section id="se11-testing-overview" class="level2">
<h2 class="anchored" data-anchor-id="se11-testing-overview"><font color="#0058AB"> SE11: Testing Overview </font></h2>
<section id="summary-20" class="level4">
<h4 class="anchored" data-anchor-id="summary-20">Summary</h4>
<p>The <a href="https://abseil.io/resources/swe-book/html/ch11.html">Testing Overview</a> chapter in the <a href="https://abseil.io/resources/swe-book">Software Engineering at Google</a> book delves into Google’s transformative approach to automated testing, unveiling their efficient validation of an extensive codebase. This strategy has significantly bolstered confidence in their code, streamlining development by leveraging automated tests, acknowledging the challenge of manually testing vast programs. Google emphasizes test size and scope, advocating for narrower, more targeted tests to cover the majority of their codebase effectively. Their mantra, “If you liked it, you should put a test on it,” underscores the focus on testing features prone to breakage for enhanced coverage. While stressing the importance of test coverage, Google also emphasizes the necessity of quality tests, cautioning against solely coverage-centric testing that may miss essential scenarios.</p>
<p>Over 15 years, this practice has not only facilitated faster development with larger teams but also accommodated rapid technological advancements. The chapter serves as a comprehensive guide, shedding light on Google’s testing philosophy, paving the way for in-depth discussions on unit tests, test doubles, and the complexities of testing larger systems. Understanding these strategies’ ‘what, why, and how’ is crucial to grasp Google’s robust testing approach, emphasizing the foundational role of automated testing in enabling software adaptation. The key takeaways stress scalable automation, balanced test suites, and the cultural shift toward comprehensive testing practices within organizations.</p>
</section>
<section id="reflection-and-use-case-7" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-7">Reflection and Use-Case</h4>
<p>The insights from this chapter underscore the pivotal role of testing as a strategic cornerstone rather than solely a technical process in software development. It emphasizes the need to integrate robust testing practices to navigate the complexities of development, fostering agility and innovation. These ideas resonate strongly with our Chasten project, where we’ve implemented various tests. However, the crucial takeaway is not just increasing test coverage but crafting high-quality tests capable of handling diverse inputs, focusing on pivotal functions and leveraging fuzzing tests. Integrating these strategies can elevate our testing approach, allowing the project to scale beyond it’s current state into the future.</p>
</section>
</section>
<section id="db2-tracing-executions" class="level2">
<h2 class="anchored" data-anchor-id="db2-tracing-executions"><font color="#004d05"> DB2: Tracing Executions </font></h2>
<section id="summary-21" class="level4">
<h4 class="anchored" data-anchor-id="summary-21">Summary</h4>
<p>The <a href="https://www.debuggingbook.org/html/Tracer.html">tracing executions</a> chapter from <a href="https://www.debuggingbook.org/">the debugging book</a> offers a comprehensive exploration of invaluable techniques essential for efficient debugging. It provides insightful methods for program tracing and event flagging, minimizing the reliance on excessive print statements. Through the utilization of sys.settrace() in conjunction with the StackInspector class, developers can seamlessly trace program events, facilitating a detailed understanding of code execution. This approach generates exhaustive logs, capturing executed code lines, variable scopes, and their respective values, offering an intricate overview of program flow. Furthermore, the chapter delves into tracking variable changes, empowering developers to pinpoint unintended modifications or undesired alterations in values, thereby enhancing precision in the debugging process. In interpreted languages like Python, the simplicity of accessing program states during execution using sys.settrace() streamlines state inspection and execution interruption. This method, enabling tracing at every code line, simplifies debugging by generating comprehensive traces for detailed post-analysis, eliminating the need for selective interactive debugging and fostering a more nuanced understanding of code behavior.</p>
</section>
<section id="reflection-and-use-case-8" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-8">Reflection and Use-Case</h4>
<p>Reflecting on the tracing and debugging mechanisms outlined in the chapter, it’s evident that incorporating tracing methods into Chasten’s test suite could substantially improve its debugging capabilities. Tracing within programs offers a detailed overview of variable interactions and execution paths, facilitating efficient debugging. However, deploying tracers for every output might be time-intensive, indicating the need to implement tracers selectively, particularly when errors occur, to optimize efficiency. Lessons learned from interpreted and compiled languages highlight the utility of debugging hooks, breakpoints, watchpoints, and code instrumentation in accessing program states and controlling execution. Moving forward, embracing tracing methods tailored to specific test scenarios within Chasten’s suite promises to enhance the debugging process significantly.</p>
</section>
</section>
</section>
<section id="week-15" class="level1">
<h1>Week 15</h1>
<section id="se12-unit-testing" class="level2">
<h2 class="anchored" data-anchor-id="se12-unit-testing"><font color="#0058AB"> SE12: Unit Testing </font></h2>
<section id="summary-22" class="level4">
<h4 class="anchored" data-anchor-id="summary-22">Summary</h4>
<p>The chapter on <a href="https://abseil.io/resources/swe-book/html/ch12.html">unit testing</a> in the <a href="https://abseil.io/resources/swe-book">Software Engineering at Google</a> book emphasizes the critical role of well-structured and robust unit tests in software development. It stresses the need for tests that maintain stability over time, cautioning against brittle tests that easily break due to minor changes in the code. By advocating for tests focusing on public APIs, testing state changes rather than interactions, and prioritizing clarity and conciseness, the chapter outlines best practices for effective unit testing. It underscores the importance of tests that verify program outputs and system states, ensuring functionality remains intact amid code changes. Additionally, it promotes the practice of writing descriptive and meaningful tests, avoiding code repetition, and emphasizing comprehensive test coverage over duplicative tests. The chapter serves as a guide for engineers, emphasizing the significance of resilient and clear unit tests to ensure software reliability and facilitate smoother development processes.</p>
</section>
<section id="reflection-and-use-case-9" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-9">Reflection and Use-Case</h4>
<p>This chapter offered detailed insights into test writing, sometimes feeling overwhelming due to the specific differences in test types. I hope to better understand and apply these principles, especially in future projects related to scientific computing. Moving ahead, I’ll reconsider our test writing, aiming to break down large test cases and avoid repetition. We should focus on concise, impactful tests while avoiding slowing down our testing suite with overly large integration tests. Integrating the “Don’t Repeat Yourself” concept will streamline our testing in Chasten, ensuring clear and efficient test cases without unnecessary duplication.</p>
</section>
</section>
<section id="db3-asserting-expectations" class="level2">
<h2 class="anchored" data-anchor-id="db3-asserting-expectations"><font color="#004d05"> DB3: Asserting Expectations </font></h2>
<section id="summary-23" class="level4">
<h4 class="anchored" data-anchor-id="summary-23">Summary</h4>
<p>The <a href="https://www.debuggingbook.org/html/Assertions.html">Asserting Expectations</a> chapter from <a href="https://www.debuggingbook.org/">the debugging book</a> sheds light on the pivotal role of assertions in verifying and ensuring a function’s expected behavior. Assertions serve as robust debugging tools, assessing specific conditions and variables to check for invariants and verify correctness during program execution. By incorporating assertions within functions or code, developers can seamlessly verify inputs, outputs, and data structures, facilitating efficient debugging without relying solely on manual inspection. Additionally, assertions play a critical role in tracking memory usage, enabling the monitoring and optimization of memory allocation for enhanced program efficiency. Lessons learned emphasize the potency of assertions in examining preconditions, postconditions, and data invariants, empowering the automation of critical debugging tasks while upholding the integrity of the runtime system. The chapter advocates for a strategic deployment of assertions without impacting the program’s correct operation, emphasizing their role in early error detection, defect localization, and effective debugging guidance.</p>
</section>
<section id="reflection-and-use-case-10" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-10">Reflection and Use-Case</h4>
<p>The inclusion of assertions within our team’s coding practices can significantly enhance our debugging capabilities. Assertions serve as simple yet powerful tools to validate program behavior, offering a quick way to ensure that functions receive correct inputs and deliver expected outputs. While they shouldn’t replace comprehensive test cases, judicious use of assertions within our codebase, especially in tools like Chasten and Cellveyor handling user inputs, can streamline error detection and improve program integrity. Embedding assertions strategically can establish a standard for program arguments, although unexpected failures on the user side could potentially lead to a suboptimal user experience if not handled carefully.</p>
<p>In light of these insights, it’s essential to consider where assertions can be logically embedded within Chasten and Cellveyor. However, it’s crucial to exercise caution and balance when implementing assertions. While they are invaluable for enhancing early error detection and defect localization, over-reliance or misuse of assertions might inadvertently impact user experience if failures occur on the user’s end. Keeping this balance in mind, we should integrate assertions thoughtfully into our codebase, maintaining a focus on improving debugging efficiency without compromising user interaction and experience.</p>
</section>
</section>
</section>
<section id="week-16" class="level1">
<h1>Week 16</h1>
<section id="db4-statistical-debugging" class="level2">
<h2 class="anchored" data-anchor-id="db4-statistical-debugging"><font color="#004d05"> DB4: Statistical Debugging </font></h2>
<section id="summary-24" class="level4">
<h4 class="anchored" data-anchor-id="summary-24">Summary</h4>
<p>The <a href="https://www.debuggingbook.org/html/StatisticalDebugger.html">Statistical Debugging</a> chapter from <a href="https://www.debuggingbook.org/">the debugging book</a> introduces the concept of statistical debugging, a technique aimed at identifying lines of code most likely to cause program failures. This method analyzes failing and passing runs, correlating them with specific code lines to pinpoint potential bugs. Employing a collector function, it tracks lines executed during program runs with varying inputs. Statistical debugging then ranks code lines by their association with failing runs, highlighting areas where failures predominantly occur. By determining the frequency of execution of different lines in failing versus passing runs, this approach identifies suspicious code segments, aiding in localizing potential bugs. Correlations between execution events and outcomes (pass/fail) offer crucial hints for debugging, particularly when events occurring mainly during failing runs are highlighted and ranked to guide the search. These insights provide significant clues, indicating whether the execution of specific code locations correlates with program failure, enhancing the debugging process.</p>
</section>
<section id="reflection-and-use-case-11" class="level4">
<h4 class="anchored" data-anchor-id="reflection-and-use-case-11">Reflection and Use-Case</h4>
<p>The lessons learned underscore the significance of identifying correlations between execution events and outcomes, especially in isolating critical instances leading to failures. However, I’m unsure about the seamless integration of these methods due to the complexity of our project’s structure. Nevertheless, I am committed to exploring these techniques further to uncover potential ways to implementation them within our project. I believe that investigating and attempting to incorporate these techniques could significantly enhance our debugging methodology and contribute to bolstering the reliability of our programs.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>