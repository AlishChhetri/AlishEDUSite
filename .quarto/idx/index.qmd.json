{"title":"Professional Précis","markdown":{"yaml":{"title":"Professional Précis","subtitle":"Author: Alish Chhetri"},"headingText":"About the Author","containsRefs":false,"markdown":"\n\n\n![Hello, my name is Alish, and I am looking forward to collaborating with everyone throughout the semester.](Alish_Chhetri.jpeg){ width=200 }\n\n\n# Week 2\n\n## <font color=\"#0058AB\"> SE1: Programming Over Time </font>\n\n#### Summary\n\nThe preface section of the SE book focuses on distinguishing the terms “software engineering\", “programming” and “computer science”. The section proposes that “software engineering” encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. It also places an emphasis on holding software engineers to the same level of rigor as other engineering disciplines. The programing over time section briefly goes over those points while introducing three fundamental principles that software organizations should keep in mind when designing, architecting, and writing their code. These principles encompass considerations of time and change, how code will need to adapt over the length of its life; scale and growth, how an organization will need to adapt as it evolves; and trade-offs and costs, how an organization makes decisions, based on the lessons of Time and Change and Scale and Growth.\n\n#### Reflection\n\nThe preface and programming over time sections outline the foundation for the book's exploration of software engineering with insights from Google's unique perspective. I believe this will not only give us an understanding of the material but also a look into how the industry, particularly Google, looks at software engineering and what level of rigor they expect.\n\n#### Use-Case\n\nThe knowledge gained from these sections can be applied to any aspect of the Chasten project, as well as to all other programs we write. The emphasis on holding software engineers to the same level of rigor as other engineering disciplines requires us to think beyond the specific use-case of a tool we develop. This ability to apply ourselves rigorously and holistically is crucial in ensuring the success in the field of software engineering.\n\n## <font color=\"#B03A2E\"> FB1: Introduction to Software Testing </font>\n\n#### Summary\n\nThe \"Introduction to Software Testing\" chapter in the Fuzzing book provided valuable insights into the world of software testing. It shows that testing is vital for discovering and rectifying potential issues in the code, contributing to improved software quality and reliability. However, it also highlighted the inherent limitations of testing – it can't guarantee a completely error-free code. The chapter's practical example of handling errors, like dividing by zero when using the square root function, illustrated the complexities of software testing, leaving me with a greater understanding of this crucial aspect of software development.\n\n#### Reflection\n\nThe \"Introduction to Software Testing\" chapter in the Fuzzing book offered valuable insights into testing programs. Testing involves finding bugs in the software, and we can make it more efficient by automating tasks like running tests and checking results. Still, it's important to realize that testing isn't foolproof; it can't ensure that the code is completely free of errors. \n\n#### Use-Case\n\nThe knowledge gained from the \"Introduction to Software Testing\" chapter can be applied effectively when testing any new software. It shows that testing is vital for discovering and rectifying potential issues in the code, contributing to improved software quality and reliability. In the case of Chasten, we should possibly look into testing different aspects of the program to improve the user experience or the program's efficiency.\n\n\n# Week 3\n\n## <font color=\"#0058AB\"> SE2: What is Software Engineering? </font>\n\n#### Summary\n\nChapter two of [Software Engineering at Google](https://abseil.io/resources/swe-book/html/ch01.html) elaborates further on the principles of time, scale, and the trade-offs. The book emphasises the idea of developing a program with a focus on maintaining it over decades, not hours. Software developed using this method requires us to be capable of changing dependencies, technology, or product requirements to ensure the longevity of a program. It then introduces a concept called Hyrum's Law, a phenomenon in software engineering whereby developers come to depend on all observable traits and behaviors of an interface, even if they are not defined in the contract. The book also states the importance of being able to improve as individual engineers to progress as an organization by sharing knowledge amongst peers. \n\n#### Reflection\n\nThe principles outlined in Chapter two of [\"Software Engineering at Google\"](https://abseil.io/resources/swe-book/html/ch01.html) underscore the critical importance of long-term thinking in software development. The focus on maintaining software over decades rather than hours encourages a mindset that prioritizes adaptability and flexibility. Hyrum's Law serves as a reminder of the organic nature of software development, highlighting how developers rely on observed behavior, even if it is not a core feature of the program. There is also an emphasis on individual improvement and knowledge sharing and how personal growth contributes to the progress of the entire organization. \n\n#### Use-Case\n\nThe core take away from this chapter is the emphasis on creating a program for the purpose maintaining it over a larger timescale. The chapter also touches on the fact that improvement to the code base is directly correlated with the improvement of the individual. In our case, Chasten will improve as we personally develop as developers. We got this!!\n\n## <font color=\"#B03A2E\"> FB2: Code Coverage </font>\n\n#### Summary\n\nThe [Code Coverage](https://www.fuzzingbook.org/html/Coverage.html#White-Box-Testing) chapter in the Fuzzing book provides a foundational understanding of code coverage in fuzz testing, highlighting its significance in discovering software vulnerabilities and offering practical insights into implementing coverage-guided fuzzing techniques. The section also introduces the concepts of white box and black box testing, essential approaches in software quality assurance. White box testing examines internal code, while black box testing assesses functionality without internal knowledge.\n\n#### Reflection\n\nIn this chapter, I gained a deeper understanding of the pivotal role testing plays in software development. The chapter's emphasis on testing cases reiterated that it's not just about writing code but ensuring its correctness and resilience under various scenarios. The book delves into a variety of debugging techniques, showcasing their practical applications, which I found particularly valuable.\n\n#### Use-Case\n\nFor our purposes writing effective test cases is critical for delivering and maintaining the chasten project over a longer timescale. We push ensure that testing is taken as seriously as the create and implementation of new code.\n\n\n# Week 4\n\n## <font color=\"#0058AB\"> SE3: How to Work Well on Teams </font>\n\n#### Summary\n\nThe [How to Work Well on Teams](https://abseil.io/resources/swe-book/html/ch02.html) chapter in the SE book emphasizes the cultural and social aspects of software engineering at Google, highlighting that software development is a collaborative effort. It stresses the importance of adapting behaviors based on key principles like humility, respect, and trust. In the software world, the myth of the solo developer persists, but the reality is that successful software endeavors, regardless of size, rely on well-functioning teams. To endure over time, software organizations must cultivate a healthy culture centered around the team, rather than individual efforts. This approach encourages creativity, risk-taking, and acceptance of occasional failures within a supportive team environment. \n\n#### Reflection\n\nThis chapter expanded upon the idea that teamwork is essential for successful software development, shedding light on the cultural and social aspects of this collaborative process within Google's software engineering landscape. It underscored the pivotal role of humility, respect, and trust in fostering effective team dynamics. The chapter also effectively dispelled the myth of the solo software developer and emphasized that, regardless of project size, a well-functioning team is the bedrock of software endeavors.\n\n#### Use-Case\n\nThis chapter has provided invaluable insights into optimizing teamwork and enhancing collaboration within the context of software engineering. It serves as a valuable resource for understanding the intricacies of working effectively as a team, particularly in a dynamic and demanding field like software development. If we want to Chasten to succeed, we must learn how to implement these practices and uphold the principles of humility, respect, and trust. We got this!\n\n## <font color=\"#B03A2E\"> FB3: Fuzzing: Breaking Things with Random Inputs </font>\n\n#### Summary\n\nThe [Fuzzing: Breaking Things with Random Inputs](https://www.fuzzingbook.org/html/Fuzzer.html) chapter of the Fuzzing Book introduces the idea of fuzzing as a powerful testing technique. Fuzzing involves the systematic generation of random or semi-random inputs to discover vulnerabilities or weaknesses in software applications. This chapter provides a comprehensive overview of fuzzing techniques, including grammar-based fuzzing and mutation-based fuzzing, and delves into the key concepts such as code coverage and crash analysis. It emphasizes the importance of automated fuzzing tools to efficiently discover and exploit software bugs.\n\n#### Reflection\n\nThe chapter's exploration of various fuzzing techniques, such as grammar-based and mutation-based fuzzing, provides a well-rounded understanding of this testing approach. Additionally, the emphasis on key concepts like code coverage and crash analysis highlights the critical role they play in identifying software bugs. The chapter's overarching message reinforces the value of automated fuzzing tools in efficiently exposing and addressing these issues, making it a fundamental resource for anyone seeking to enhance software robustness and security.\n\n#### Use-Case\n\nThis chapter has equipped us with invaluable insights into the world of fuzzing, offering a comprehensive understanding of its significance as a testing technique. Just as teamwork is essential in software engineering, fuzzing stands as a powerful and cost-effective tool for improving code coverage and identifying vulnerabilities in our software applications. For our purpose, this testing technique could be employed into the Chasten program to effective test for bugs produced by source code inputs or config files. This technique maybe prove invaluable for Chasten, however I believe that it will be better used during the ladder half of the semester when we start the development of the Astronaught tool.\n\n# Week 5\n\n## <font color=\"#0058AB\"> SE4: Knowledge Sharing </font>\n\n#### Summary\n\nThe [Knowledge Sharing](https://abseil.io/resources/swe-book/html/ch03.html) chapter in the SE book highlights the idea of organizations understanding their own problem domain and being equipped to answer their own questions. This involves having both experts with knowledge and effective mechanisms to disseminate that knowledge. These mechanisms range from simple actions like asking questions and documenting knowledge to more structured approaches like tutorials and classes. Crucially, fostering a culture of learning within the organization is essential, and this necessitates creating an environment where individuals feel psychologically safe to admit when they lack knowledge.\n\nIn addition, the chapter underscores the challenge of \"Information islands,\" which represent knowledge fragmentation occurring in different parts of an organization that do not communicate with one another or utilize shared resources. In such an environment, each group develops its own unique way of approaching tasks and challenges. This phenomenon often leads to several critical issues:\n\n- Information Fragmentation: Within these isolated \"islands,\" there exists an incomplete understanding of the larger organizational context and objectives, resulting in suboptimal decision-making.\n\n- Information Duplication: The lack of communication between these groups leads to the duplication of efforts, as each island independently reinvents solutions and processes.\n\n- Information Skew: These islands may adopt varying approaches to address the same issues, potentially causing conflicts and inconsistencies when their methodologies intersect.\n\n#### Reflection\n\nOverall, this chapter underscores the significance of knowledge as a critical asset for software engineering organizations. Fostering a culture of open and honest knowledge sharing, underpinned by psychological safety, is essential for organizational resilience and growth. By starting with simple practices like asking questions and documenting knowledge, and by encouraging teaching and accessibility to resources, organizations can efficiently distribute knowledge and adapt to changing circumstances over time.\n\n#### Use-Case\n\nThis chapter has equipped us with invaluable insights into the world of knowledge sharing. In order to implement these practices and foster psychological safety, we must start by ensuring accessibility to resources and expertise, and incentivize teaching and collaboration. We must also recognize that the approach may evolve as the organization's needs change. After we learn how to effectivily share our knowledge, we will grow as both developers and programmers.\n\n## <font color=\"#B03A2E\"> FB4: Mutation Analysis </font>\n\n#### Summary\n\nThe [Mutation Analysis](https://www.fuzzingbook.org/html/MutationAnalysis.html) chapter of the Fuzzing Book presents an alternative approach to evaluate the efficiency of a test suite: by introducing mutations, which are simulated defects, into the code and then examining whether the test suite can identify these simulated defects. The underlying concept is that if the test suite cannot detect these artificial mutations, it is likely to overlook actual software bugs as well.\n\nIn addition, the chapter emphasizes a limitation of structural coverage measures, which solely measure code execution without verifying the correctness of program outputs. For instance, the presence or absence of assertions in test cases may not affect coverage metrics, even if the test cases fail to validate correct program behavior. Two example test functions, ineffective_test_1 and ineffective_test_2, illustrate this issue:\n\n```python\ndef ineffective_test_1():\n    execute_the_program_as_a_whole()\n    assert True\n\ndef ineffective_test_2():\n    try:\n        execute_the_program_as_a_whole()\n    except:\n        pass\n    assert True\n```\n\nThese tests may achieve 100% code coverage but are ineffective at discovering actual bugs.\n\nTo address this problem, the chapter hints at the idea of injecting bugs into the program to evaluate test suite effectiveness. However, it acknowledges the challenges in doing so, including the potential bias introduced by developers and the time-consuming nature of manually creating these bugs. Consequently, the chapter highlights the need for more robust approaches to ensure the utility of test suites.\n\n#### Reflection\n\nThe concept of mutation analysis introduced in the Fuzzing Book's chapter offers a valuable perspective on assessing the effectiveness of test suites. It underscores the inadequacy of relying solely on structural coverage measures, as these may not guarantee the correctness of program outputs. The provided code examples, ineffective_test_1 and ineffective_test_2, vividly illustrate the disparity between achieving high coverage and actually uncovering bugs within the software.\n\nFurthermore, the chapter's discussion on the challenges of injecting artificial bugs raises important considerations about the practicality and potential bias associated with such an approach. This information highlights the need for a balanced and comprehensive testing strategy that not only targets code coverage but also prioritizes the detection of real-world software defects.\n\n#### Use-Case\n\nThis chapter's insights into test suite evaluation emphasize the need to complement structural coverage measures with mutation analysis, offering a more robust approach to software testing. By introducing simulated defects and assessing whether the test suite can detect them, we can identify vulnerabilities that structural coverage alone might overlook. It's crucial to recognize that structural coverage metrics should not be the sole focus; instead, we should prioritize comprehensive testing that validates software correctness and robustness. This may require adjustments to our testing methodologies and practices. By incorporating mutation analysis and a holistic testing approach, we can strengthen our projects, enhance software quality, and grow as proficient developers, ultimately delivering more reliable and user-friendly software products.\n\n# Week 6\n\n### <font color=\"#FFD801\"> Executable Examination and Fall Break </font>\n\n# Week 7\n\n## <font color=\"#0058AB\"> SE5: Engineering for Equity </font>\n\n#### Summary\n\nThe [Engineering for Equity](https://abseil.io/resources/swe-book/html/ch04.html) chapter of the Software Engineering book highlights the importance of recognizing and addressing bias in \nsoftware development. It emphasizes the need for diversity and inclusivity in the industry to ensure that software products are designed for a wide range of users. The chapter discusses how \nunconscious bias can inadvertently harm underrepresented groups and lead to failures in product development. A case study about Google's image recognition algorithms failing to consider racial \ninclusion is presented as an example of such failures. The chapter stresses the need for engineers to focus on understanding diverse user demographics and challenges, as well as the importance \nof building multicultural capacity in development teams. It also advocates for inclusive design from the beginning of the development process and emphasizes the responsibility of engineers in \nmaking equitable systems. The chapter encourages continuous improvement, measurement of equity, and collaboration with diversity and inclusion experts to create more inclusive software products.\n\n#### Reflection\n\nThe chapter serves as a reminder of the ethical and practical imperative of addressing bias and promoting inclusivity in software engineering. It acknowledges that the industry has a long way \nto go in achieving true inclusivity and diversity. It calls for a shift in mindset, from building for everyone to building with everyone, involving users at every stage of product development. \nIt stresses the need for engineers to understand the impact of their products on a diverse user base and challenges traditional approaches that prioritize speed over equity.\n\n#### Use-Case\n\nThis chapter provides a valuable guide for software engineers and organizations to make inclusivity and diversity central to their product development processes. It encourages engineers to \nconsider all user groups, especially those who may face challenges in using their products, and to collaborate with experts in diversity and inclusion. By following these principles, engineers \nand organizations can build more equitable and inclusive software that serves a broader range of users, ultimately improving the industry as a whole.\n\n## <font color=\"#B03A2E\"> FB5: Mutation-Based Fuzzing </font>\n\n#### Summary\n\nThe [Mutation-Based Fuzzing](https://www.fuzzingbook.org/html/MutationFuzzer.html) chapter of the Fuzzing Book introduces the idea of mutational-based fuzzing, a technique used in software engineering testing. It involves making small, random modifications to valid inputs to explore a wider range of program behaviors while maintaining their structural integrity. Mutational fuzzing is particularly valuable in testing software that interacts with external data sources, such as file parsers, network protocols, or APIs. This approach helps identify edge cases, uncover hidden software bugs, and ensure the robustness and reliability of programs that process various inputs.\n\nThe chapter provides an example of mutation based fuzzing in the following code blocks:\n\n```python\ndef mutate(s: str) -> str:\n    \"\"\"Return s with a random mutation applied\"\"\"\n    mutators = [\n        delete_random_character,\n        insert_random_character,\n        flip_random_character\n    ]\n    mutator = random.choice(mutators)\n    # print(mutator)\n    return mutator(s)\n```\n\n```python\nfor i in range(10):\n    print(repr(mutate(\"A quick brown fox\")))\n```\n\n```\nexample output:\n\n'A qzuick brown fox'\n' quick brown fox'\n'A quick Brown fox'\n'A qMuick brown fox'\n'A qu_ick brown fox'\n'A quick bXrown fox'\n'A quick brown fx'\n'A quick!brown fox'\n'A! quick brown fox'\n'A quick brownfox'\n```\n\nThe mutate function take a string as an input and applies a random mutation to it by choosing from a set of mutator functions: delete_random_character, insert_random_character, and flip_random_character. It uses the random.choice function to randomly select one of these mutators and then applies it to the input string. The provided loop prints ten randomly mutated versions of the input string, \"A quick brown fox.\" The example output shows us how the input text can be modified, however you can still clearly tell what the original input was, thus demonstrating the mutation of existing content and not generation of new content.\n\n#### Reflection\n\nThe Mutation-Based Fuzzing chapter of the Fuzzing Book introduces mutational-based fuzzing as a practical technique for software engineering testing. It emphasizes the significance of maintaining structural validity in input modifications, allowing for more precise exploration of a program's behaviors. The provided code example illustrates the process of mutating existing content, highlighting the approach's ability to generate subtle variations while retaining the original context. This chapter showcases the value of mutational fuzzing in enhancing software robustness, particularly in scenarios involving external data sources, and serves as a reminder of the importance of nuanced testing methods that go beyond basic input validation.\n\n#### Use-Case\n\nDevelopers can apply the principles outlined in this chapter to systematically mutate valid inputs, allowing for the exploration of program behaviors beyond mere input processing. This approach is particularly valuable when testing software that interacts with external data sources such as file parsers which fits our needs. By implementing mutational fuzzing, we can identify edge cases, uncover hidden software defects, and ensure comprehensive software quality and reliability, ultimately enhancing the overall testing and quality assurance processes in software development.\n\n","srcMarkdownNoYaml":"\n\n# About the Author\n\n![Hello, my name is Alish, and I am looking forward to collaborating with everyone throughout the semester.](Alish_Chhetri.jpeg){ width=200 }\n\n\n# Week 2\n\n## <font color=\"#0058AB\"> SE1: Programming Over Time </font>\n\n#### Summary\n\nThe preface section of the SE book focuses on distinguishing the terms “software engineering\", “programming” and “computer science”. The section proposes that “software engineering” encompasses not just the act of writing code, but all of the tools and processes an organization uses to build and maintain that code over time. It also places an emphasis on holding software engineers to the same level of rigor as other engineering disciplines. The programing over time section briefly goes over those points while introducing three fundamental principles that software organizations should keep in mind when designing, architecting, and writing their code. These principles encompass considerations of time and change, how code will need to adapt over the length of its life; scale and growth, how an organization will need to adapt as it evolves; and trade-offs and costs, how an organization makes decisions, based on the lessons of Time and Change and Scale and Growth.\n\n#### Reflection\n\nThe preface and programming over time sections outline the foundation for the book's exploration of software engineering with insights from Google's unique perspective. I believe this will not only give us an understanding of the material but also a look into how the industry, particularly Google, looks at software engineering and what level of rigor they expect.\n\n#### Use-Case\n\nThe knowledge gained from these sections can be applied to any aspect of the Chasten project, as well as to all other programs we write. The emphasis on holding software engineers to the same level of rigor as other engineering disciplines requires us to think beyond the specific use-case of a tool we develop. This ability to apply ourselves rigorously and holistically is crucial in ensuring the success in the field of software engineering.\n\n## <font color=\"#B03A2E\"> FB1: Introduction to Software Testing </font>\n\n#### Summary\n\nThe \"Introduction to Software Testing\" chapter in the Fuzzing book provided valuable insights into the world of software testing. It shows that testing is vital for discovering and rectifying potential issues in the code, contributing to improved software quality and reliability. However, it also highlighted the inherent limitations of testing – it can't guarantee a completely error-free code. The chapter's practical example of handling errors, like dividing by zero when using the square root function, illustrated the complexities of software testing, leaving me with a greater understanding of this crucial aspect of software development.\n\n#### Reflection\n\nThe \"Introduction to Software Testing\" chapter in the Fuzzing book offered valuable insights into testing programs. Testing involves finding bugs in the software, and we can make it more efficient by automating tasks like running tests and checking results. Still, it's important to realize that testing isn't foolproof; it can't ensure that the code is completely free of errors. \n\n#### Use-Case\n\nThe knowledge gained from the \"Introduction to Software Testing\" chapter can be applied effectively when testing any new software. It shows that testing is vital for discovering and rectifying potential issues in the code, contributing to improved software quality and reliability. In the case of Chasten, we should possibly look into testing different aspects of the program to improve the user experience or the program's efficiency.\n\n\n# Week 3\n\n## <font color=\"#0058AB\"> SE2: What is Software Engineering? </font>\n\n#### Summary\n\nChapter two of [Software Engineering at Google](https://abseil.io/resources/swe-book/html/ch01.html) elaborates further on the principles of time, scale, and the trade-offs. The book emphasises the idea of developing a program with a focus on maintaining it over decades, not hours. Software developed using this method requires us to be capable of changing dependencies, technology, or product requirements to ensure the longevity of a program. It then introduces a concept called Hyrum's Law, a phenomenon in software engineering whereby developers come to depend on all observable traits and behaviors of an interface, even if they are not defined in the contract. The book also states the importance of being able to improve as individual engineers to progress as an organization by sharing knowledge amongst peers. \n\n#### Reflection\n\nThe principles outlined in Chapter two of [\"Software Engineering at Google\"](https://abseil.io/resources/swe-book/html/ch01.html) underscore the critical importance of long-term thinking in software development. The focus on maintaining software over decades rather than hours encourages a mindset that prioritizes adaptability and flexibility. Hyrum's Law serves as a reminder of the organic nature of software development, highlighting how developers rely on observed behavior, even if it is not a core feature of the program. There is also an emphasis on individual improvement and knowledge sharing and how personal growth contributes to the progress of the entire organization. \n\n#### Use-Case\n\nThe core take away from this chapter is the emphasis on creating a program for the purpose maintaining it over a larger timescale. The chapter also touches on the fact that improvement to the code base is directly correlated with the improvement of the individual. In our case, Chasten will improve as we personally develop as developers. We got this!!\n\n## <font color=\"#B03A2E\"> FB2: Code Coverage </font>\n\n#### Summary\n\nThe [Code Coverage](https://www.fuzzingbook.org/html/Coverage.html#White-Box-Testing) chapter in the Fuzzing book provides a foundational understanding of code coverage in fuzz testing, highlighting its significance in discovering software vulnerabilities and offering practical insights into implementing coverage-guided fuzzing techniques. The section also introduces the concepts of white box and black box testing, essential approaches in software quality assurance. White box testing examines internal code, while black box testing assesses functionality without internal knowledge.\n\n#### Reflection\n\nIn this chapter, I gained a deeper understanding of the pivotal role testing plays in software development. The chapter's emphasis on testing cases reiterated that it's not just about writing code but ensuring its correctness and resilience under various scenarios. The book delves into a variety of debugging techniques, showcasing their practical applications, which I found particularly valuable.\n\n#### Use-Case\n\nFor our purposes writing effective test cases is critical for delivering and maintaining the chasten project over a longer timescale. We push ensure that testing is taken as seriously as the create and implementation of new code.\n\n\n# Week 4\n\n## <font color=\"#0058AB\"> SE3: How to Work Well on Teams </font>\n\n#### Summary\n\nThe [How to Work Well on Teams](https://abseil.io/resources/swe-book/html/ch02.html) chapter in the SE book emphasizes the cultural and social aspects of software engineering at Google, highlighting that software development is a collaborative effort. It stresses the importance of adapting behaviors based on key principles like humility, respect, and trust. In the software world, the myth of the solo developer persists, but the reality is that successful software endeavors, regardless of size, rely on well-functioning teams. To endure over time, software organizations must cultivate a healthy culture centered around the team, rather than individual efforts. This approach encourages creativity, risk-taking, and acceptance of occasional failures within a supportive team environment. \n\n#### Reflection\n\nThis chapter expanded upon the idea that teamwork is essential for successful software development, shedding light on the cultural and social aspects of this collaborative process within Google's software engineering landscape. It underscored the pivotal role of humility, respect, and trust in fostering effective team dynamics. The chapter also effectively dispelled the myth of the solo software developer and emphasized that, regardless of project size, a well-functioning team is the bedrock of software endeavors.\n\n#### Use-Case\n\nThis chapter has provided invaluable insights into optimizing teamwork and enhancing collaboration within the context of software engineering. It serves as a valuable resource for understanding the intricacies of working effectively as a team, particularly in a dynamic and demanding field like software development. If we want to Chasten to succeed, we must learn how to implement these practices and uphold the principles of humility, respect, and trust. We got this!\n\n## <font color=\"#B03A2E\"> FB3: Fuzzing: Breaking Things with Random Inputs </font>\n\n#### Summary\n\nThe [Fuzzing: Breaking Things with Random Inputs](https://www.fuzzingbook.org/html/Fuzzer.html) chapter of the Fuzzing Book introduces the idea of fuzzing as a powerful testing technique. Fuzzing involves the systematic generation of random or semi-random inputs to discover vulnerabilities or weaknesses in software applications. This chapter provides a comprehensive overview of fuzzing techniques, including grammar-based fuzzing and mutation-based fuzzing, and delves into the key concepts such as code coverage and crash analysis. It emphasizes the importance of automated fuzzing tools to efficiently discover and exploit software bugs.\n\n#### Reflection\n\nThe chapter's exploration of various fuzzing techniques, such as grammar-based and mutation-based fuzzing, provides a well-rounded understanding of this testing approach. Additionally, the emphasis on key concepts like code coverage and crash analysis highlights the critical role they play in identifying software bugs. The chapter's overarching message reinforces the value of automated fuzzing tools in efficiently exposing and addressing these issues, making it a fundamental resource for anyone seeking to enhance software robustness and security.\n\n#### Use-Case\n\nThis chapter has equipped us with invaluable insights into the world of fuzzing, offering a comprehensive understanding of its significance as a testing technique. Just as teamwork is essential in software engineering, fuzzing stands as a powerful and cost-effective tool for improving code coverage and identifying vulnerabilities in our software applications. For our purpose, this testing technique could be employed into the Chasten program to effective test for bugs produced by source code inputs or config files. This technique maybe prove invaluable for Chasten, however I believe that it will be better used during the ladder half of the semester when we start the development of the Astronaught tool.\n\n# Week 5\n\n## <font color=\"#0058AB\"> SE4: Knowledge Sharing </font>\n\n#### Summary\n\nThe [Knowledge Sharing](https://abseil.io/resources/swe-book/html/ch03.html) chapter in the SE book highlights the idea of organizations understanding their own problem domain and being equipped to answer their own questions. This involves having both experts with knowledge and effective mechanisms to disseminate that knowledge. These mechanisms range from simple actions like asking questions and documenting knowledge to more structured approaches like tutorials and classes. Crucially, fostering a culture of learning within the organization is essential, and this necessitates creating an environment where individuals feel psychologically safe to admit when they lack knowledge.\n\nIn addition, the chapter underscores the challenge of \"Information islands,\" which represent knowledge fragmentation occurring in different parts of an organization that do not communicate with one another or utilize shared resources. In such an environment, each group develops its own unique way of approaching tasks and challenges. This phenomenon often leads to several critical issues:\n\n- Information Fragmentation: Within these isolated \"islands,\" there exists an incomplete understanding of the larger organizational context and objectives, resulting in suboptimal decision-making.\n\n- Information Duplication: The lack of communication between these groups leads to the duplication of efforts, as each island independently reinvents solutions and processes.\n\n- Information Skew: These islands may adopt varying approaches to address the same issues, potentially causing conflicts and inconsistencies when their methodologies intersect.\n\n#### Reflection\n\nOverall, this chapter underscores the significance of knowledge as a critical asset for software engineering organizations. Fostering a culture of open and honest knowledge sharing, underpinned by psychological safety, is essential for organizational resilience and growth. By starting with simple practices like asking questions and documenting knowledge, and by encouraging teaching and accessibility to resources, organizations can efficiently distribute knowledge and adapt to changing circumstances over time.\n\n#### Use-Case\n\nThis chapter has equipped us with invaluable insights into the world of knowledge sharing. In order to implement these practices and foster psychological safety, we must start by ensuring accessibility to resources and expertise, and incentivize teaching and collaboration. We must also recognize that the approach may evolve as the organization's needs change. After we learn how to effectivily share our knowledge, we will grow as both developers and programmers.\n\n## <font color=\"#B03A2E\"> FB4: Mutation Analysis </font>\n\n#### Summary\n\nThe [Mutation Analysis](https://www.fuzzingbook.org/html/MutationAnalysis.html) chapter of the Fuzzing Book presents an alternative approach to evaluate the efficiency of a test suite: by introducing mutations, which are simulated defects, into the code and then examining whether the test suite can identify these simulated defects. The underlying concept is that if the test suite cannot detect these artificial mutations, it is likely to overlook actual software bugs as well.\n\nIn addition, the chapter emphasizes a limitation of structural coverage measures, which solely measure code execution without verifying the correctness of program outputs. For instance, the presence or absence of assertions in test cases may not affect coverage metrics, even if the test cases fail to validate correct program behavior. Two example test functions, ineffective_test_1 and ineffective_test_2, illustrate this issue:\n\n```python\ndef ineffective_test_1():\n    execute_the_program_as_a_whole()\n    assert True\n\ndef ineffective_test_2():\n    try:\n        execute_the_program_as_a_whole()\n    except:\n        pass\n    assert True\n```\n\nThese tests may achieve 100% code coverage but are ineffective at discovering actual bugs.\n\nTo address this problem, the chapter hints at the idea of injecting bugs into the program to evaluate test suite effectiveness. However, it acknowledges the challenges in doing so, including the potential bias introduced by developers and the time-consuming nature of manually creating these bugs. Consequently, the chapter highlights the need for more robust approaches to ensure the utility of test suites.\n\n#### Reflection\n\nThe concept of mutation analysis introduced in the Fuzzing Book's chapter offers a valuable perspective on assessing the effectiveness of test suites. It underscores the inadequacy of relying solely on structural coverage measures, as these may not guarantee the correctness of program outputs. The provided code examples, ineffective_test_1 and ineffective_test_2, vividly illustrate the disparity between achieving high coverage and actually uncovering bugs within the software.\n\nFurthermore, the chapter's discussion on the challenges of injecting artificial bugs raises important considerations about the practicality and potential bias associated with such an approach. This information highlights the need for a balanced and comprehensive testing strategy that not only targets code coverage but also prioritizes the detection of real-world software defects.\n\n#### Use-Case\n\nThis chapter's insights into test suite evaluation emphasize the need to complement structural coverage measures with mutation analysis, offering a more robust approach to software testing. By introducing simulated defects and assessing whether the test suite can detect them, we can identify vulnerabilities that structural coverage alone might overlook. It's crucial to recognize that structural coverage metrics should not be the sole focus; instead, we should prioritize comprehensive testing that validates software correctness and robustness. This may require adjustments to our testing methodologies and practices. By incorporating mutation analysis and a holistic testing approach, we can strengthen our projects, enhance software quality, and grow as proficient developers, ultimately delivering more reliable and user-friendly software products.\n\n# Week 6\n\n### <font color=\"#FFD801\"> Executable Examination and Fall Break </font>\n\n# Week 7\n\n## <font color=\"#0058AB\"> SE5: Engineering for Equity </font>\n\n#### Summary\n\nThe [Engineering for Equity](https://abseil.io/resources/swe-book/html/ch04.html) chapter of the Software Engineering book highlights the importance of recognizing and addressing bias in \nsoftware development. It emphasizes the need for diversity and inclusivity in the industry to ensure that software products are designed for a wide range of users. The chapter discusses how \nunconscious bias can inadvertently harm underrepresented groups and lead to failures in product development. A case study about Google's image recognition algorithms failing to consider racial \ninclusion is presented as an example of such failures. The chapter stresses the need for engineers to focus on understanding diverse user demographics and challenges, as well as the importance \nof building multicultural capacity in development teams. It also advocates for inclusive design from the beginning of the development process and emphasizes the responsibility of engineers in \nmaking equitable systems. The chapter encourages continuous improvement, measurement of equity, and collaboration with diversity and inclusion experts to create more inclusive software products.\n\n#### Reflection\n\nThe chapter serves as a reminder of the ethical and practical imperative of addressing bias and promoting inclusivity in software engineering. It acknowledges that the industry has a long way \nto go in achieving true inclusivity and diversity. It calls for a shift in mindset, from building for everyone to building with everyone, involving users at every stage of product development. \nIt stresses the need for engineers to understand the impact of their products on a diverse user base and challenges traditional approaches that prioritize speed over equity.\n\n#### Use-Case\n\nThis chapter provides a valuable guide for software engineers and organizations to make inclusivity and diversity central to their product development processes. It encourages engineers to \nconsider all user groups, especially those who may face challenges in using their products, and to collaborate with experts in diversity and inclusion. By following these principles, engineers \nand organizations can build more equitable and inclusive software that serves a broader range of users, ultimately improving the industry as a whole.\n\n## <font color=\"#B03A2E\"> FB5: Mutation-Based Fuzzing </font>\n\n#### Summary\n\nThe [Mutation-Based Fuzzing](https://www.fuzzingbook.org/html/MutationFuzzer.html) chapter of the Fuzzing Book introduces the idea of mutational-based fuzzing, a technique used in software engineering testing. It involves making small, random modifications to valid inputs to explore a wider range of program behaviors while maintaining their structural integrity. Mutational fuzzing is particularly valuable in testing software that interacts with external data sources, such as file parsers, network protocols, or APIs. This approach helps identify edge cases, uncover hidden software bugs, and ensure the robustness and reliability of programs that process various inputs.\n\nThe chapter provides an example of mutation based fuzzing in the following code blocks:\n\n```python\ndef mutate(s: str) -> str:\n    \"\"\"Return s with a random mutation applied\"\"\"\n    mutators = [\n        delete_random_character,\n        insert_random_character,\n        flip_random_character\n    ]\n    mutator = random.choice(mutators)\n    # print(mutator)\n    return mutator(s)\n```\n\n```python\nfor i in range(10):\n    print(repr(mutate(\"A quick brown fox\")))\n```\n\n```\nexample output:\n\n'A qzuick brown fox'\n' quick brown fox'\n'A quick Brown fox'\n'A qMuick brown fox'\n'A qu_ick brown fox'\n'A quick bXrown fox'\n'A quick brown fx'\n'A quick!brown fox'\n'A! quick brown fox'\n'A quick brownfox'\n```\n\nThe mutate function take a string as an input and applies a random mutation to it by choosing from a set of mutator functions: delete_random_character, insert_random_character, and flip_random_character. It uses the random.choice function to randomly select one of these mutators and then applies it to the input string. The provided loop prints ten randomly mutated versions of the input string, \"A quick brown fox.\" The example output shows us how the input text can be modified, however you can still clearly tell what the original input was, thus demonstrating the mutation of existing content and not generation of new content.\n\n#### Reflection\n\nThe Mutation-Based Fuzzing chapter of the Fuzzing Book introduces mutational-based fuzzing as a practical technique for software engineering testing. It emphasizes the significance of maintaining structural validity in input modifications, allowing for more precise exploration of a program's behaviors. The provided code example illustrates the process of mutating existing content, highlighting the approach's ability to generate subtle variations while retaining the original context. This chapter showcases the value of mutational fuzzing in enhancing software robustness, particularly in scenarios involving external data sources, and serves as a reminder of the importance of nuanced testing methods that go beyond basic input validation.\n\n#### Use-Case\n\nDevelopers can apply the principles outlined in this chapter to systematically mutate valid inputs, allowing for the exploration of program behaviors beyond mere input processing. This approach is particularly valuable when testing software that interacts with external data sources such as file parsers which fits our needs. By implementing mutational fuzzing, we can identify edge cases, uncover hidden software defects, and ensure comprehensive software quality and reliability, ultimately enhancing the overall testing and quality assurance processes in software development.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"darkly","title":"Professional Précis","subtitle":"Author: Alish Chhetri"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}